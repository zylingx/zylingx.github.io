<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内嵌框架]]></title>
    <url>%2F2018%2F09%2F21%2F%E5%89%8D%E7%AB%AF%2FHTML%2F10%E5%86%85%E5%B5%8C%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[iframe标签会创建包含另外一个html文件的内联框架（即在本网页内划分一部分用来显示另外一个网页） &lt;iframe src=&quot;https://www.baidu.com&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; frameborder属性： 定义边框 scrolling属性： 定义是否有滚动条 width和height属性： 定义宽度和高度 a标签与iframe标签&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;myframe&quot;&gt;页面一&lt;/a&gt; &lt;a href=&quot;https://www.qq.com&quot; target=&quot;myframe&quot;&gt;页面二&lt;/a&gt; &lt;a href=&quot;https://www.163.com&quot; target=&quot;myframe&quot;&gt;页面三&lt;/a&gt; &lt;iframe src=&quot;https://www.baidu.com&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; name=&quot;myframe&quot;&gt;&lt;/iframe&gt; 需要在a标签中指定target属性与iframe的name属性进行关联]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单]]></title>
    <url>%2F2018%2F09%2F19%2F%E5%89%8D%E7%AB%AF%2FHTML%2F09%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[表单用于搜集与交互用户的需求信息，表单由不同类型的标签组成。 form标签&lt;form&gt; &lt;div&gt; &lt;/div&gt; &lt;/form&gt; &lt;form&gt;标签：定义表单区域整体，在此标签中再使用不同的表单控件来实现不同类型的信息输入 &lt;div&gt; 标签：表示一块内容，没有具体的语义。前面有提到过 表单控件label标签&lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;/div&gt; label标签:定义表单控件旁边的文字 &lt;div&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;test&quot; name=&quot;username&quot; id=&quot;username&quot;&gt; &lt;/div&gt; for属性：点击当前label标签可以激活指定控件 在激活指定控件时，需要给控件指定id属性 注：主要是提高用户一些细节上的体验，多用于单选框与复选框 input标签单行文本输入框&lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=&quot;test&quot; name=&quot;username&quot;&gt; &lt;/div&gt; type属性：赋值为test，表示这是一个单行文本框 name属性：后面说到再说 &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;/div&gt; type属性：赋值为password，表示这里面输入的内容以暗文(星号)的形式出现 单选框&lt;div&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt; &lt;label&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt; &lt;label&gt;女&lt;/label&gt; &lt;/div&gt; type属性：赋值为radio，表示这是一个单选框 name属性：单选框逻辑上应该只能选择一个，将name属性设为一样就可以互斥 复选框&lt;div&gt; &lt;label&gt;爱好：&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;like&quot;&gt; &lt;label&gt;睡觉&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;like&quot;&gt; &lt;label&gt;游泳&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;like&quot;&gt; &lt;label&gt;看书&lt;/label&gt; &lt;/div&gt; type属性：赋值为checkbox，表示这是一个复选框 name属性：name属性一样是为了方便在处理页面获取表单传递的值。 按钮&lt;input type=&quot;button&quot; name=&quot;bt&quot; value=&quot;按钮&quot;&gt; type属性：赋值为button，表示这是一个按钮,没指定无意义 提交按钮&lt;input type=&quot;submit&quot; name=&quot;put&quot; value=&quot;提交&quot;&gt; type属性：赋值为submit，表示这是一个提交表单按钮 value属性：给value属性赋值可以定义按钮上的文字 还可以用图片控件代替submit按钮提交，一般会导致提交两次，不建议使用。如： &lt;input type=&quot;image&quot; src=&quot;xxx.gif&quot;&gt; 重置按钮&lt;input type=&quot;reset&quot; name=&quot;re&quot; value=&quot;重置&quot;&gt; type属性：赋值为reset，表示这是一个重置表单按钮 存值&lt;input type=&quot;hidden&quot; name=&quot;hid&quot; value=&quot;12315&quot;&gt; type属性：赋值为hidden，不表示表单控件，而是用来在页面上存储一些值 在大多数数据传输时，有时会需要存储一些值，这时hidden就派上用场了，hidden不会在页面上显示 上传照片&lt;div&gt; &lt;label&gt;&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;filename&quot;&gt; &lt;/div&gt; 多行文本输入框&lt;div&gt; &lt;label&gt;个人简介：&lt;/label&gt; &lt;textarea name=&quot;text&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; 下拉列表框&lt;div&gt; &lt;label&gt;籍贯：&lt;/label&gt; &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; select标签：表示这是一个下拉列表框 option标签：表示这是下拉列表框的一个子元素 name属性与value属性绝大部分表单控件都有value属性，大多与name属性一起传输，通常在提交表单时需要用到 单行文本框：指定value值则表示为默认值，会在输入框中显示，在文本框中输入后会被输入的内容取代 单选框：value值多被指定为数字，如性别，男的value=”1”,女的value=”0”等等 提交表单数据&lt;form action=&quot;www.zylin.xyz&quot; method=&quot;get&quot;&gt; &lt;div&gt; &lt;/div&gt; &lt;/form&gt; action属性：定义表单数据提交地址(如注册界面的数据的提交)，上面的案例，我是把数据提交给我博客 method属性：定义提交方式， get方式指定提交方式为地址栏提交，表单的数据都可以在地址栏上看到 post方式指定为http协议的方式提交，可以在http报文中看到，默认是get提交方式]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考完国二了]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%97%A5%E5%B8%B8%2F%E6%97%A5%E8%AE%B0%2F003%E8%80%83%E5%AE%8C%E5%9B%BD%E4%BA%8C%E4%BA%86%2F</url>
    <content type="text"><![CDATA[emmmm,在前几天，都在看国二的资料，在昨天，终于考完国二了，开心，撒花，题目还是挺简单的，那么，接下来继续自己的学习之旅，这里先说明一下，更新的可能不会太多，因为至少有一半时间，我都会花在学习大数据上]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据处理]]></title>
    <url>%2F2018%2F09%2F18%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F05%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[操作CSV文件CSV(Comma-Separated Values)即逗号分隔值，CSV文件是一个纯文本文件，最早用在简单的数据库里，其格式简单，具备很强的开放性，非常容易被导入各种PC表格及数据库，比如Excel表格等。 CSV文件中每行相当于一条记录（相当于数据表中的一行），用 “，”（半角逗号）分割每行的不同字段。举例如下： 1, 23, 32,12 2, 44, 12, 56 对应Excel表格，CSV文件中的一行对应Excel的一行，CSV同一行中的半角逗号相当于Excel表格同一行分割不同单元格的竖线。 Python中导入csv数据的三种方法使用标准类库csv导入这个类库中的reader()函数用来导入CSV文件。当CSV文件被读入后，可以利用这些数据生成一个NumPy数组 使用类库Numpy导入使用NumPy的loadtxt()函数导入数据。使用这个函数处理的数据没有文件头，并且所有的数据结构都是一样的，也就是说，数据类型是一样的。 使用类库Pandas导入通过Pandas来导入CSV文件要使用pandas.read_csv()函数。这个函数的返回值是DataFrame，可以很方便的进行下一步的处理，实际操作过程中推荐使用这种方法。所以前面两种就不介绍了，专心介绍这种方法 使用read_csv函数导入CSV文件语法：read_csv(file, encoding)]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表格]]></title>
    <url>%2F2018%2F09%2F15%2F%E5%89%8D%E7%AB%AF%2FHTML%2F08%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[常用标签1、table标签：声明一个表格容器 2、tr标签：定义表格中的一行 3、td和th标签：定义一行中的一个单元格，td代表普通单元格，th表示表头单元格(也就是表的字段名) 常用属性：1、border 定义表格的边框 2、cellpadding 定义单元格内内容与边框的距离 3、cellspacing 定义单元格与单元格之间的距离 4、align 设置单元格中内容的水平对齐方式,设置值有：left | center | right 5、valign 设置单元格中内容的垂直对齐方式 top | middle | bottom 6、colspan 设置单元格水平合并 7、rowspan 设置单元格垂直合并 8、border-collapse:collapse 设置边框合并，制作一像素宽的边线的表格 传统布局传统的布局方式就是使用table来做整体页面的布局，布局的技巧归纳为如下几点： 1、定义表格宽高，将border、cellpadding、cellspacing全部设置为0 2、单元格里面嵌套表格 3、单元格中的元素和嵌套的表格用align和valign设置对齐方式 4、通过属性或者css样式设置单元格中元素的样式 传统布局目前应用： 1、快速制作用于演示的html页面 2、商业推广EDM制作(广告邮件)]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%89%8D%E7%AB%AF%2FHTML%2F07%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[有序列表在网页上定义一个有编号的内容列表可以用&lt;ol&gt;、&lt;li&gt;配合使用来实现，代码如下： &lt;ol&gt; &lt;li&gt;列表文字一&lt;/li&gt; &lt;li&gt;列表文字二&lt;/li&gt; &lt;li&gt;列表文字三&lt;/li&gt; &lt;/ol&gt; 在网页上生成的列表，每条项目上会按1、2、3编号，有序列表在实际开发中较少使用。 无序列表在网页上定义一个无编号的内容列表可以用&lt;ul&gt;、&lt;li&gt;配合使用来实现，代码如下： &lt;ul&gt; &lt;li&gt;列表文字一&lt;/li&gt; &lt;li&gt;列表文字二&lt;/li&gt; &lt;li&gt;列表文字三&lt;/li&gt; &lt;/ul&gt; 在网页上生成的列表，每条项目上会有一个小图标，这个小图标在不同浏览器上显示效果不同，所以一般会用样式去掉默认的小图标，如果需要图标，可以用样式自定义图标，从而达到在不同浏览器上显示的效果相同,实际开发中一般用这种列表。 定义列表定义列表通常用于术语的定义。标签表示列表的整体。标签定义术语的题目。标签是术语的解释。一个中可以有多个题目和解释，代码如下： &lt;h3&gt;前端三大块&lt;/h3&gt; &lt;dl&gt; &lt;dt&gt;html&lt;/dt&gt; &lt;dd&gt;负责页面的结构&lt;/dd&gt; &lt;dt&gt;css&lt;/dt&gt; &lt;dd&gt;负责页面的表现&lt;/dd&gt; &lt;dt&gt;javascript&lt;/dt&gt; &lt;dd&gt;负责页面的行为&lt;/dd&gt; &lt;/dl&gt; sublime中的快捷键快速生成在写标签时，sublime有快捷键可以帮助我们快速输入 ul&gt;li*5 这个命令的意思是，ul与li是要快速生成的标签名，”&gt;”指的是li是ul的子标签，”*5”表示生成5行 ul&gt;(li&gt;a)*3 这个命令的意思是，ul标签只生成一次，li标签与a标签同时生成三次 dl&gt;(dt+dd)*3 这个命令的意思是同级标签之间用加号连接，需要生成多次的就用括号括起 同时编辑将光标定位到需要编辑的位置，按住ctrl键不放，点击需要编辑的位置，然后再松开，这样可以同时编辑多处]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于博文上有未完成的说明]]></title>
    <url>%2F2018%2F09%2F10%2F%E6%97%A5%E5%B8%B8%2F%E6%97%A5%E8%AE%B0%2F002%E5%85%B3%E4%BA%8E%E5%8D%9A%E6%96%87%E4%B8%8A%E6%9C%89%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[这里先说明一下，如果你在某篇博文标题上看到了有个括号引起的后缀（未完成），说明博文没有写完，不是不写了，而是想说后面会补上。可能是因为更重要的事情而暂时停止学习。比如我10月13号有个大数据比赛要参加，所以目前我会暂停我正在学习的内容，利用西蒙学习法，专心的学习数据分析这方面的知识，等这个阶段过去后，会继续以前的学习，那时才会补上之前没有更新完的内容，嗯，就是这样]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据框DataFrame]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F03%E6%95%B0%E6%8D%AE%E6%A1%86DataFrame%2F</url>
    <content type="text"><![CDATA[学习来源易百教程https://www.yiibai.com/pandas/前往易百教程学习，这边只是记录我学习的笔记 数据框数据框是二维数据结构，即数据以行和列的表格方式排列。 格式pandas.DataFrame( data, index, columns, dtype, copy) 参数 data 数据采取各种形式，如:ndarray，series，map，lists，dict，constant和另一个DataFrame。 index 对于行标签，如果没有索引默认np.arange(n)被传递。 columns 对于列标签，如果没有索引默认np.arange(n)被传递。 dtype 每列的数据类型。 copy 默认值为False，如果为True则此命令用于复制数据。 创建创建一个空的数据框import pandas as pd df = pd.DataFrame() print(df) #-----输出结果----- Empty DataFrame Columns: [] Index: [] 用列表创建DataFrame例1： import pandas as pd data = [1,2,3,4,5] df = pd.DataFrame(data) print(df) #-----输出结果----- 0 0 1 1 2 2 3 3 4 4 5 例2： import pandas as pd data = [[&apos;Alex&apos;,10],[&apos;Bob&apos;,12],[&apos;Clarke&apos;,13]] df = pd.DataFrame(data,columns=[&apos;Name&apos;,&apos;Age&apos;]) print(df) #-----输出结果----- Name Age 0 Alex 10 1 Bob 12 2 Clarke 13 例3：用列表字典创建 import pandas as pd data = [{&apos;a&apos;: 1, &apos;b&apos;: 2},{&apos;a&apos;: 5, &apos;b&apos;: 10, &apos;c&apos;: 20}] df = pd.DataFrame(data, index=[&apos;first&apos;, &apos;second&apos;]) print(df) #-----输出结果----- a b c first 1 2 NaN second 5 10 20.0 例4： import pandas as pd data = [{&apos;a&apos;: 1, &apos;b&apos;: 2},{&apos;a&apos;: 5, &apos;b&apos;: 10, &apos;c&apos;: 20}] df1 = pd.DataFrame(data, index=[&apos;first&apos;, &apos;second&apos;], columns=[&apos;a&apos;, &apos;b&apos;]) df2 = pd.DataFrame(data, index=[&apos;first&apos;, &apos;second&apos;], columns=[&apos;a&apos;, &apos;b1&apos;]) print(df1) print(df2) #-----输出结果----- #df1 output a b first 1 2 second 5 10 #df2 output a b1 first 1 NaN second 5 NaN 注：df1使用的是与字典key相同的列名，所以字典的value被抽出，但创建时没有包含字典key c,所以没有key c的值。而df2用了一个和字典key不同的索引，没有对应字典key的value,所以将nan附加到缺失的区域 用字典创建DataFrame例1： import pandas as pd data = {&apos;Name&apos;:[&apos;Tom&apos;, &apos;Jack&apos;, &apos;Steve&apos;, &apos;Ricky&apos;],&apos;Age&apos;:[28,34,29,42]} df = pd.DataFrame(data, index=[&apos;rank1&apos;,&apos;rank2&apos;,&apos;rank3&apos;,&apos;rank4&apos;]) print(df） #-----输出结果----- Age Name rank1 28 Tom rank2 34 Jack rank3 29 Steve rank4 42 Ricky 例2：用包含系列的字典创建 import pandas as pd d = {&apos;one&apos; : pd.Series([1, 2, 3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]), &apos;two&apos; : pd.Series([1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])} df = pd.DataFrame(d) print(df) #-----输出结果----- one two a 1.0 1 b 2.0 2 c 3.0 3 d NaN 4 列操作选择列import pandas as pd d = {&apos;one&apos; : pd.Series([1, 2, 3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]), &apos;two&apos; : pd.Series([1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])} df = pd.DataFrame(d) print(df[&apos;one&apos;]) #-----输出结果----- a 1.0 b 2.0 c 3.0 d NaN Name: one, dtype: float64 添加列import pandas as pd d = {&apos;one&apos; : pd.Series([1, 2, 3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]), &apos;two&apos; : pd.Series([1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])} df = pd.DataFrame(d) print(&quot;通过传递系列添加新列:&quot;) df[&apos;three&apos;] = pd.Series([10,20,30], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) print(df) print(&quot;使用DataFrame中的现有列添加新列:&quot;) df[&apos;four&apos;]=df[&apos;one&apos;]+df[&apos;three&apos;] print(df) #-----输出结果----- 通过传递系列添加新列: one two three a 1.0 1 10.0 b 2.0 2 20.0 c 3.0 3 30.0 d NaN 4 NaN 使用DataFrame中的现有列添加新列: one two three four a 1.0 1 10.0 11.0 b 2.0 2 20.0 22.0 c 3.0 3 30.0 33.0 d NaN 4 NaN NaN 删除列import pandas as pd d = {&apos;one&apos; : pd.Series([1, 2, 3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]), &apos;two&apos; : pd.Series([1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]), &apos;three&apos; : pd.Series([10,20,30], index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;])} df = pd.DataFrame(d) print(&quot;Our dataframe is:&quot;) print(df) # using del function print(&quot;Deleting the first column using DEL function:&quot;) del df[&apos;one&apos;] print(df) # using pop function print(&quot;Deleting another column using POP function:&quot;) df.pop(&apos;two&apos;) print(df) #-----输出结果----- Our dataframe is: one three two a 1.0 10.0 1 b 2.0 20.0 2 c 3.0 30.0 3 d NaN NaN 4 Deleting the first column using DEL function: three two a 10.0 1 b 20.0 2 c 30.0 3 d NaN 4 Deleting another column using POP function: three a 10.0 b 20.0 c 30.0 d NaN 行操作选择行例1：通过索引检索行 import pandas as pd d = {&apos;one&apos; : pd.Series([1, 2, 3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]), &apos;two&apos; : pd.Series([1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])} df = pd.DataFrame(d) print(df.loc[&apos;b&apos;]) #-----输出结果----- one 2.0 two 2.0 Name: b, dtype: float64 例2：通过切片检索行 import pandas as pd d = {&apos;one&apos; : pd.Series([1, 2, 3], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]), &apos;two&apos; : pd.Series([1, 2, 3, 4], index=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])} df = pd.DataFrame(d) print df[2:4] #-----输出结果----- one two c 3.0 3 d NaN 4 增加行import pandas as pd df = pd.DataFrame([[1, 2], [3, 4]], columns = [&apos;a&apos;,&apos;b&apos;]) df2 = pd.DataFrame([[5, 6], [7, 8]], columns = [&apos;a&apos;,&apos;b&apos;]) df = df.append(df2) print(df) #-----输出结果----- a b 0 1 2 1 3 4 0 5 6 1 7 8 删除行使用索引标签从DataFrame中删除或删除行。 如果标签重复，则会删除多行。 import pandas as pd df = pd.DataFrame([[1, 2], [3, 4]], columns = [&apos;a&apos;,&apos;b&apos;]) df2 = pd.DataFrame([[5, 6], [7, 8]], columns = [&apos;a&apos;,&apos;b&apos;]) df = df.append(df2) # Drop rows with label 0 df = df.drop(0) print(df) #-----输出结果----- a b 1 3 4 1 7 8 在上面的例子中，一共有两行被删除，因为这两行包含相同的标签0。]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像与链接]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%89%8D%E7%AB%AF%2FHTML%2F06%E5%9B%BE%E5%83%8F%E4%B8%8E%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[图像&lt;img&gt;标签可以在网页上插入一张图片，通过“src”属性定义图片的地址，通过“alt”属性定义图片加载失败时显示的文字，以及对搜索引擎和盲人读屏软件的支持。 &lt;img src=&quot;images/pic.jpg&quot; alt=&quot;小女孩&quot; /&gt; &lt;img标签还有width 和 height两个属性，在插入图片时，这两个属性可以指定显示图片的大小，不指定则按图片的大小来显示。 绝对路径和相对路径像网页上插入图片这种外部文件，需要定义文件的引用地址，引用外部文件还包括引用外部样式表，javascript等等，引用地址分为绝对地址和相对地址。 绝对地址：相对于磁盘的位置去定位文件的地址 相对地址：相对于引用文件本身去定位被引用的文件地址 绝对地址在整体文件迁移时会因为磁盘和顶层目录的改变而找不到文件，相对路径就没有这个问题。相对路径的定义技巧： “ ./ ” 表示当前文件所在目录下，比如：“./pic.jpg” 表示当前目录下的pic.jpg的图片，这个使用时可以省略。 “ ../ ” 表示当前文件所在目录下的上一级目录，比如：“../images/pic.jpg” 表示当前目录下的上一级目录下的images文件夹中的pic.jpg的图片。 如果图片来源于网络，那么写网络的url地址： &lt;img src=&quot;http://img.zcool.cn/community/0117e2571b8b246ac72538120dd8a4.jpg@1280w_1l_2o_100sh.jpg&quot; width=&quot;300&quot; height=&quot;120&quot;/&gt; 链接&lt;a&gt;标签可以在网页上定义一个链接地址，通过src属性定义跳转的地址，通过title属性定义鼠标悬停时弹出的提示文字框。 &lt;a href=&quot;#&quot;&gt;&lt;/a&gt; &lt;!-- # 表示链接到页面顶部 --&gt; &lt;a href=&quot;http://www.zylin.xyz/&quot; title=&quot;链接到某某博客网站&quot;&gt;朝阳旅行者 &lt;/a&gt; 给图片添加跳转链接给图片添加跳转链接很简单，只需要在&lt;img&gt;标签外包裹一个&lt;a&gt;标签就好了 &lt;a href=&quot;http://www.zylin.xyz/&quot; title=&quot;无&quot;&gt; &lt;img src=&quot;http://img.zcool.cn/a.jpg /&gt; &lt;/a&gt; 定义页面内滚动跳转页面内定义了“id”或者“name”的元素，可以通过a标签链接到它的页面滚动位置，前提是页面要足够高，有滚动条，且元素不能在页面顶部，否则页面不会滚动。 &lt;a href=&quot;#&quot;&gt;链接到页面顶部&lt;/a&gt; &lt;a href=&quot;#mao1&quot;&gt;标题一&lt;/a&gt; ...... ...... &lt;h3 id=&quot;mao1&quot;&gt;跳转到的标题&lt;/h3&gt; target属性我们通过链接默认是会覆盖原网页，可以通过修改target属性修改 默认是_self,该网址会覆盖原网页打开 &lt;a href=&quot;http://www.zylin.xyz/&quot; target=&quot;_self&quot;&gt;朝阳旅行者&lt;/a&gt; 修改为_blank，会打开一个新网页标签 &lt;a href=&quot;http://www.zylin.xyz/&quot; target=&quot;_blank&quot;&gt;朝阳旅行者 &lt;/a&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系列和数据框的属性、方法]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F04%E7%B3%BB%E5%88%97%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A1%86%E7%9A%84%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习来源易百教程https://www.yiibai.com/pandas/可前往易百教程学习，这边只是记录我学习的笔记 系列的属性和方法 属性或方法 描述 1 axes 返回由行的索引构成的列表。 2 dtype 返回对象的数据类型（dtype）。 3 empty 如果系列为空，则返回True。 4 ndim 返回对象的维数。系列是一个1D数据结构 5 size 返回系列的长度 6 values 返回系列中的值 7 head(num) 查看前n行，默认数量为5，可以自定义显示的行数。 8 tail(num) 查看后n行，默认数量为5，可以自定义显示的行数。 案例import numpy as np import pandas as pd # 系列 df = pd.Series(np.random.randn(10)) print(&quot;axes:\n&quot;, df.axes) axes: [RangeIndex(start=0, stop=10, step=1)] print(&quot;dtype:\n&quot;, df.dtype) dtype: float64 print(&quot;empty:\n&quot;, df.empty) empty: False print(&quot;ndim:\n&quot;, df.ndim) ndim: 1 print(&quot;size:\n&quot;, df.size) size: 10 print(&quot;values:\n&quot;, df.values) values: [ 0.48917638 0.03055365 0.62873303 -0.64996325 -0.18307531 0.20838626 -1.92778815 -0.57171211 -0.84953731 -1.37837361] print(&quot;head 5:\n&quot;, df.head()) head 5: 0 0.489176 1 0.030554 2 0.628733 3 -0.649963 4 -0.183075 dtype: float64 print(&quot;head 2:\n&quot;, df.head(2)) head 2: 0 0.489176 1 0.030554 dtype: float64 print(&quot;tail 5:\n&quot;, df.tail()) tail 5: 5 0.208386 6 -1.927788 7 -0.571712 8 -0.849537 9 -1.378374 dtype: float64 print(&quot;tail 2:\n&quot;, df.tail(2)) tail 2: 8 -0.849537 9 -1.378374 dtype: float64 数据框的属性和方法属性或方法 描述 T 转置行和列。 axes 返回行、列索引构成的列表 dtypes 返回每列的数据类型 empty 返回True表示对象为空。 ndim 返回对象的维数，数据框是一个2D的数据结构(2D的意思是二维的意思) shape 返回一个元组(a，b)，其中a表示行数，b表示列数。 size 返回组成这个数据框的元素个数 values 返回数据框中的值 head() 返回开头前n行。 tail() 返回最后n行。 案例import pandas as pd import numpy as np d = {&apos;Name&apos;:pd.Series([&apos;Tom&apos;,&apos;James&apos;,&apos;Ricky&apos;,&apos;Vin&apos;,&apos;Steve&apos;,&apos;Minsu&apos;,&apos;Jack&apos;]), &apos;Age&apos;:pd.Series([25,26,25,23,30,29,23]), &apos;Rating&apos;:pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])} df2 = pd.DataFrame(d) print(df2) Name Age Rating 0 Tom 25 4.23 1 James 26 3.24 2 Ricky 25 3.98 3 Vin 23 2.56 4 Steve 30 3.20 5 Minsu 29 4.60 6 Jack 23 3.80 print(df2.T) 0 1 2 3 4 5 6 Name Tom James Ricky Vin Steve Minsu Jack Age 25 26 25 23 30 29 23 Rating 4.23 3.24 3.98 2.56 3.2 4.6 3.8 print(&quot;axes:\n&quot;, df2.axes) axes: [RangeIndex(start=0, stop=7, step=1), Index([&apos;Name&apos;, &apos;Age&apos;, &apos;Rating&apos;], dtype=&apos;object&apos;)] print(&quot;dtypes:\n&quot;, df2.dtypes) dtypes: Name object Age int64 Rating float64 dtype: object #注：Series可以用dtype，也可以用dtypes，但DataFrame只能用dtypes print(&quot;empty:\n&quot;, df2.empty) empty: False print(&quot;ndim:\n&quot;, df2.ndim) ndim: 2 print(&quot;shape:\n&quot;, df2.shape) shape: (7, 3) print(&quot;size:\n&quot;, df2.size) size: 21 print(&quot;values:\n&quot;, df2.values) values: [[&apos;Tom&apos; 25 4.23] [&apos;James&apos; 26 3.24] [&apos;Ricky&apos; 25 3.98] [&apos;Vin&apos; 23 2.56] [&apos;Steve&apos; 30 3.2] [&apos;Minsu&apos; 29 4.6] [&apos;Jack&apos; 23 3.8]] print(&quot;head 5:\n&quot;, df2.head()) head 5: Name Age Rating 0 Tom 25 4.23 1 James 26 3.24 2 Ricky 25 3.98 3 Vin 23 2.56 4 Steve 30 3.20 print(&quot;tail 5:\n&quot;, df2.tail()) tail 5: Name Age Rating 2 Ricky 25 3.98 3 Vin 23 2.56 4 Steve 30 3.20 5 Minsu 29 4.60 6 Jack 23 3.80]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块与语义标签]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%89%8D%E7%AB%AF%2FHTML%2F05%E5%9D%97%E4%B8%8E%E8%AF%AD%E4%B9%89%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[块div标签表示一块内容，没有具体的语义。&lt;div&gt; 标签定义 HTML 文档中的一个分隔区块或者一个区域部分。常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化。 &lt;div style=&quot;color:#0000FF&quot;&gt; &lt;h3&gt;这是一个在 div 元素中的标题。&lt;/h3&gt; &lt;p&gt;这是一个在 div 元素中的文本。&lt;/p&gt; &lt;/div&gt; span标签表示一行中的一小段内容，没有具体的语义。&lt;span&gt; 用于对文档中的行内元素进行组合。 标签没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。它提供了一种将文本的一部分或者文档的一部分独立出来的方式。 &lt;p&gt;我的母亲有 &lt;span style=&quot;color:blue&quot;&gt;蓝色&lt;/span&gt; 的眼睛。&lt;/p&gt; 语义标签1、em标签 行内元素，表示语气中的强调词 2、i标签 行内元素，原本没有语义，w3c强加了语义，表示专业词汇 3、b标签 行内元素，原本没有语义，w3c强加了语义，表示文档中的关键字或者产品名 4、strong标签 行内元素，表示非常重要的内容 在布局的时候多使用语义化的标签，搜索引擎在爬网的时候能认识这些标签，理解文档的结构，方便网站的收录。]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系列Series]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F02%E7%B3%BB%E5%88%97Series%2F</url>
    <content type="text"><![CDATA[Pandas处理以下三个数据结构 系列(Series) 数据框(DataFrame) 面板(Panel) 这些数据结构构建在Numpy数组之上，这意味着它们很快。 系列系列(Series)是能够保存任何类型的数据(整数，字符串，浮点数，Python对象等)的一维标记数组。轴标签统称为索引。 1》系列的格式 2》系列的创建 3》系列的检索 格式pandas.Series( data, index, dtype, copy) 参数 data 数据采取各种形式，如：ndarray，list，constants index 索引值必须是唯一的和散列的，与数据的长度相同。 如果没有索引默认np.arange(n)被传递。 dtype dtype用于数据类型。如果没有，将推断数据类型 copy 复制数据，默认为false。 创建创建一个空系列import pandas as pd s = pd.Series() print(s) #-----输出结果----- Series([], dtype: float64) 从ndarray创建一个系列import pandas as pd import numpy as np data = np.array([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]) s = pd.Series(data) print(s) #-----输出结果----- 0 a 1 b 2 c 3 d dtype: object 注：这里没有传递任何索引，所以默认分配了从0到len(data)-1的索引，即：0到3。 import pandas as pd import numpy as np data = np.array([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]) s = pd.Series(data,index=[100,101,102,103]) print(s) #-----输出结果----- 100 a 101 b 102 c 103 d dtype: object 在这里传递了索引值。现在可以在输出中看到自定义的索引值。 从字典创建一个系列字典(dict)可以作为输入传递，如果没有指定索引，则按排序顺序取得字典键以构造索引。 如果传递了索引，索引中与标签对应的数据中的值将被拉出。 import pandas as pd import numpy as np data = {&apos;a&apos; : 0., &apos;b&apos; : 1., &apos;c&apos; : 2.} s = pd.Series(data) print(s) #-----输出结果----- a 0.0 b 1.0 c 2.0 dtype: float64 从标量创建一个系列如果数据是标量值，则必须提供索引。将重复该值以匹配索引的长度。 import pandas as pd import numpy as np s = pd.Series(5, index=[0, 1, 2, 3]) print(s) #-----输出结果----- 0 5 1 5 2 5 3 5 dtype: int64 检索数据切片方式检索数据例1：检索第一个元素。比如已经知道数组从零开始计数，第一个元素存储在零位置等等。 import pandas as pd s = pd.Series([1,2,3,4,5],index = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]) print(s[0]) #-----输出结果----- 1 例2：检索系列中的前三个元素。 import pandas as pd s = pd.Series([1,2,3,4,5],index = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]) print(s[:3]) #-----输出结果----- a 1 b 2 c 3 dtype: int64 例3:检索最后三个元素 import pandas as pd s = pd.Series([1,2,3,4,5],index = [‘a’,’b’,’c’,’d’,’e’]) print(s[-3:]) #-----输出结果----- c 3 d 4 e 5 dtype: int64 使用索引检索数据import pandas as pd s = pd.Series([1,2,3,4,5],index = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]) print(s[[&apos;a&apos;,&apos;c&apos;,&apos;d&apos;]]) #-----输出结果----- a 1 c 3 d 4 dtype: int64 注：如果不包含索引，则会出现异常。]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html 段落]]></title>
    <url>%2F2018%2F09%2F08%2F%E5%89%8D%E7%AB%AF%2FHTML%2F04%E6%AE%B5%E8%90%BD%2F</url>
    <content type="text"><![CDATA[HTML 段落段落是通过 &lt;p&gt; 标签定义的。实例 &lt;p&gt;这是一个段落 &lt;/p&gt; &lt;p&gt;这是另一个段落&lt;/p&gt; HTML换行如果您希望在不产生一个新段落的情况下进行换行，请使用 &lt;br /&gt; 标签：实例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这个&lt;br /&gt;段落&lt;br /&gt;演示了分行的效果&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; HTML 输出无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果.当显示页面时，浏览器会移除源代码中多余的空格和空行。所有连续的空格或空行都会被算作一个空格。需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。实例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;春晓&lt;/h1&gt; &lt;p&gt; 春眠不觉晓， 处处闻啼鸟。 夜来风雨声， 花落知多少。 &lt;/p&gt; &lt;p&gt;注意，浏览器忽略了源代码中的排版（省略了多余的空格和换行）。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; HTML 空格代码中成段的文字，如果文字间想空多个空格，在代码中空多个空格，在渲染成网页时只会显示一个空格，如果想显示多个空格，可以使用空格的字符实体 &lt;!-- 在段落前想缩进两个文字的空格，使用空格的字符实体：&amp;nbsp; --&gt; &lt;p&gt; &amp;nbsp;&amp;nbsp;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用&lt;br /&gt; 文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件&lt;br /&gt; 渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。&lt;/p&gt; HTML的大于、小于号如果想在网页中显示大于号或小于号，最好使用字符实体，因为在网页上显示 “&lt;” 和 “&gt;” 会误认为是标签 &lt;!-- “&lt;” 和 “&gt;” 的字符实体为 &amp;lt; 和 &amp;gt; --&gt; &lt;p&gt; 3 &amp;lt; 5 &lt;br /&gt; 10 &amp;gt; 5 &lt;/p&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌搜索引擎]]></title>
    <url>%2F2018%2F09%2F08%2F%E6%97%A5%E5%B8%B8%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F5%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[请大家在使用的时候一定要牢记“社会主义核心价值观”，这样才能实现中华民族伟大复兴。我们这一代人，是有历史使命的。 谷歌搜索镜像1、https://qooqle.tw/ 2、https://g.codery.ga/ 3、https://rain.likeso.ml/ 4、https://coderschool.2345.ga/ 5、https://a.scmor.website/ 6、https://c.scmor.website/ 7、https://d.scmor.website/ 谷歌学术镜像1、https://a.glgoo.top/scholar/ 2、https://b.glgoo.top/scholar/ 3、https://c.glgoo.top/scholar/ 4、https://x.glgoo.top/scholar/ 5、https://c3.glgoo.top/scholar/ 维基百科镜像站https://www.weijibaike.site/]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html 标题]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%89%8D%E7%AB%AF%2FHTML%2F03%E6%A0%87%E9%A2%98%2F</url>
    <content type="text"><![CDATA[HTML 标题标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 标签进行定义的.&lt;h1&gt; 定义最大的标题。 &lt;h6&gt; 定义最小的标题。实例 &lt;h1&gt;这是一个标题。&lt;/h1&gt; &lt;h2&gt;这是一个标题。&lt;/h2&gt; &lt;h3&gt;这是一个标题。&lt;/h3&gt; 注: 浏览器会自动地在标题的前后添加空行。 请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成粗体或大号的文本而使用标题。 搜索引擎使用标题为您的网页的结构和内容编制索引。用标题来呈现文档结构。 应该将 h1 用作主标题（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。 HTML 水平线&lt;hr /&gt; 标签在 HTML 页面中创建水平线。hr 元素可用于分隔内容。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;hr 标签定义水平线：&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;这是段落。&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;这是段落。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; HTML 注释可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。写法如下: &lt;!-- 这是一个注释 --&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumPy模块(未完成)]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F01NumPy%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[学习来源博客园 Little_Rookie ：https://www.cnblogs.com/nxld/p/6058572.html博客园 蓝夜的转载 ： https://www.cnblogs.com/lanye/p/5420203.html 将从这5个方面来介绍numpy模块的内容： 1）基本概念 2）数组 3）数组元素的获取--普通索引、切片、布尔索引和花式索引 4）统计函数与线性代数运算 5）随机数的生成 基本概念为什么需要numpyPython中提供了list容器，可以当作数组使用。但列表中的元素可以是任何对象，因此列表中保存的是对象的指针，这样一来，为了保存一个简单的列表[1,2,3]。就需要三个指针和三个整数对象。对于数值运算来说，这种结构显然不够高效。Python虽然也提供了array模块，但其只支持一维数组，不支持多维数组，也没有各种运算函数。因而不适合数值运算。而NumPy的出现弥补了这些不足。（——摘自张若愚的《Python科学计算》） 事实上只有一句话，numpy消耗资源少，并且运算采用的是矩阵运算，比 python 自带的字典或者列表快好多 NumPy数组NumPy数组是一个多维数组对象，称为ndarray。其由两部分组成： 实际的数据 描述这些数据的元数据 大部分操作仅针对于元数据，而不改变底层实际的数据。 关于NumPy数组有几点必需了解的： NumPy数组的下标从0开始。 同一个NumPy数组中所有元素的类型必须是相同的。 数组数组这节细分为下面 个方面来介绍 1）数组的属性 2）数组的创建 3) 数组的类型 数组的属性ndarray.ndim：查看数组的维数(最简单的方法是看&apos;array(&apos;后面紧跟着有几个括号[或者中括号]，代表有几维) eg:np.array(`[`1,...表示一维 np.array(`((`1,...表示二维 np.array(`[[[`0,...表示三维 ndarray.shape：数组的维度 例如二维数组中，表示数组的“行数”和“列数”。 eg:np.array(((1,1,2,3),(5,8,13,21),(34,55,89,144))) np.shape =&gt;&gt;&gt; (3, 4) eg:np.array([[[0, 1 ,2], [0, 1, 2]], [[0, 1, 2],[0, 1, 2]]]) =&gt;&gt;&gt; (2, 2, 3) ndarray.size：数组元素的总个数 eg:np.array(((1,1,2,3),(5,8,13,21),(34,55,89,144))) np.size =&gt;&gt;&gt; 12 ndarray.dtype：查看数组的数据类型(在定义数组时，可以有dtype指定数据类型) eg:print(arr1.dtype) 查看数据类型 eg:arr = np.ones((2,3,4), dtype=int16) 指定数据类型 数组的创建numpy中使用array()函数创建数组,array的首个参数一定是一个序列，可以是元组也可以是列表。 一维数组的创建通过arange()函数生成数组import numpy as np #大多数人习惯把numpy简写为np，今后不再做解释 arr1 = np.arange(10) #arange的使用相当于Python的range，但arange生成的是一个数组 print(type(arr1)) #系统自带的type只能测出arr1是一个&lt;class &apos;numpy.ndarray&apos;&gt; print(arr1.dtype) #通过numpy生成的数组的方法，才能看出它的数据类型,该例类型为int32 注：arange和range一样的方式使用，同样有开始值，结束值，步长等参数 生成无序元素数组如果一维数组不是一个规律的有序元素，而是人为的输入，就需要array()函数创建了。 import numpy as np arr1 = np.array([1,1,2,3,5,8,13,21]) #array中的数据可以是元组类型也可以是列表类型 a.ndim –&gt; 1 a.shape –&gt; (8,) 等距产生n个数当arange使用浮点数参数时，由于浮点数精度有限，通常无法预测获得的元素个数。这时我们就需要linspace方法格式 np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 语法 指定start和stop，默认等距产生等差数列个数为 50 指定num，可以指定产生等差数列的个数 如果数列的元素个数指定 endpoint :如果为True，则stop是最后一个样本。 否则，它不包括在内。 默认为True。 retstep :如果为True，则返回（samples，step），其中step是样本之间的间距。 dtype :指定元素的数据类型 案例 &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5) array([ 2. , 2.25, 2.5 , 2.75, 3. ]) &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False) array([ 2. , 2.2, 2.4, 2.6, 2.8]) &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True) (array([ 2. , 2.25, 2.5 , 2.75, 3. ]), 0.25) 多维数组的创建多维数组的创建实际上和python中的列表、元组使用一样，多维都是嵌套 二维数组的创建import numpy as np arr1 = np.array(((1,1,2,3),(5,8,13,21),(34,55,89,144))) #数据可以是元组也可以是列表 print(arr1) a.ndim –&gt; 2 a.shape –&gt; (3, 4) 打印 [[ 1 1 2 3] [ 5 8 13 21] [ 34 55 89 144]] 三维数组的创建import numpy as np arr1 = np.array([[[0, 1 ,2], [0, 1, 2]], [[0, 1, 2],[0, 1, 2]]]) a.ndim –&gt; 3 a.shape –&gt; (2, 2， 3) 注：对于高维数组在将来的数据分析中用的比较少，这里关于高维数组的创建就不赘述了，构建方法仍然是嵌套的方式。 特殊数组通常，刚开始时数组的元素未知，而数组的大小已知。因此，NumPy提供了一些使用占位符创建数组的函数。这些函数有助于满足除了数组扩展的需要，同时降低了高昂的运算开销。 用函数zeros可创建一个全是0的数组，用函数ones可创建一个全为1的数组，函数empty创建一个内容随机并且依赖与内存状态的数组。默认创建的数组类型(dtype)都是float64。 元素全为1的数组import numpy as np one_arr = np.ones([3,4]) #这里只用指出行列的多少就行了 print(one_arr) 打印 [[1. 1. 1. 1.] [1. 1. 1. 1.] [1. 1. 1. 1.]] 元素全为0的数组import numpy as np zero_arr = np.zeros([3,4]) #这里只用指出行列的多少就行了 print(zero_arr) 打印 [[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]] 空数组import numpy as np empty_arr = np.empty([3,4]) print(empty_arr) 打印 [[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]] 单位矩阵格式 np.eye(N, M=None, k=0, dtype=&lt;class &apos;float&apos;&gt;) 语法 N 行数 M 列数,默认无 k 对角线的位置，0的时候是正对角线，+1就是对角线向上移，-1就是对角线向下移 案例 import numpy as np eye_arr = np.eye(3) 打印 [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] 案例 import numpy as np eye_arr = np.eye(5，k=1) 打印 [[0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.] [0. 0. 0. 0. 0.]] 对角矩阵格式 np.diag(v, k=0) 语法 提取对角线或构造对角线阵列。 v: 如果`v`是二维数组，则返回其第对角线。 如果`v`是一维数组,则返回其对角矩阵 k: 对角线的位置，0的时候是正对角线，+1就是对角线向上移，-1就是对角线向下移 案例 import numpy as np arr1 = np.array([1,1,2,3,5,8,13,21]) diag_arr = np.diag(arr1) print(diag_arr) 打印 [[ 0 1 0 0 0 0 0 0 0] [ 0 0 1 0 0 0 0 0 0] [ 0 0 0 2 0 0 0 0 0] [ 0 0 0 0 3 0 0 0 0] [ 0 0 0 0 0 5 0 0 0] [ 0 0 0 0 0 0 8 0 0] [ 0 0 0 0 0 0 0 13 0] [ 0 0 0 0 0 0 0 0 21] [ 0 0 0 0 0 0 0 0 0]]案例 import numpy as np arr2 = np.array(((1,1,2,3),(5,8,13,21),(34,55,89,144))) diag_arr = np.diag(arr2) print(diag_arr) 打印 [ 1 8 89] 数组的类型名称 描述 bool 用一个字节存储的布尔类型（True或False） inti 由所在平台决定其大小的整数（一般为int32或int64） int8 一个字节大小，-128 至 127 int16 整数，-32768 至 32767 int32 整数，-2 ** 31 至 2 ** 32 -1 int64 整数，-2 ** 63 至 2 ** 63 - 1 uint8 无符号整数，0 至 255 uint16 无符号整数，0 至 65535 uint32 无符号整数，0 至 2 ** 32 - 1 uint64 无符号整数，0 至 2 ** 64 - 1 float16 半精度浮点数：16位，正负号1位，指数5位，精度10位 float32 单精度浮点数：32位，正负号1位，指数8位，精度23位 float64或float 双精度浮点数：64位，正负号1位，指数11位，精度52位 complex64 复数，分别用两个32位浮点数表示实部和虚部 complex128或complex 复数，分别用两个64位浮点数表示实部和虚部]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html 元素与属性]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%89%8D%E7%AB%AF%2FHTML%2F02%E5%85%83%E7%B4%A0%E4%B8%8E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[HTML 元素HTML 元素语法HTML 元素以开始标签起始，以结束标签终止，元素的内容是开始标签与结束标签之间的内容 ，大多数 HTML 元素可拥有属性 不要忘记结束标签忘记使用结束标签会产生不可预料的结果或错误。 HTML 空元素没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 在开始标签中添加斜杠，比如&lt;br /&gt;，是关闭空元素的正确方法 HTML 提示：使用小写标签HTML 标签对大小写不敏感：&lt;P&gt; 等同于 &lt;p&gt;。但万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。 注意 一些标签的使用，切记所有标签都需要闭合，不管是单体标签还是成对标签。（尽管目前浏览器是识别有些标签不闭合的情况，但是取的最好的保证兼容性，使用闭合） 标签写法要用小写字母（有些版本对大小写可认为相同，而xhtml中强制使用小写） 属性HTML 属性HTML 元素可以设置属性，属性一般描述于开始标签，属性总是以名称/值对的形式出现，比如：name=”value”。 HTML 属性与引号属性值应该始终被包括在引号内。 双引号是最常用的，不过使用单引号也没有问题。 提示: 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name=’John “ShotGun” Nelson’ HTML使用小写属性属性和属性值对大小写不敏感。但最好使用小写属性。]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预备知识]]></title>
    <url>%2F2018%2F09%2F05%2F%E5%BA%9F%E5%BC%83%E5%8D%9A%E6%96%87%2F02%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[HTML 标题HTML 标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签来定义的.实例 &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;h2&gt;这是一个标题&lt;/h2&gt; &lt;h3&gt;这是一个标题&lt;/h3&gt; HTML 段落HTML 段落是通过标签 &lt;p&gt; 来定义的.实例 &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; HTML 链接HTML 链接是通过标签&lt;a&gt;来定义的.实例 &lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt; 提示:在 href 属性中指定链接的地址。(您将在本教程稍后的章节中学习更多有关属性的知识). HTML 图像HTML 图像是通过标签 &lt;img&gt; 来定义的.实例 &lt;img src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt; 注意： 图像的名称和尺寸是以属性的形式提供的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基础概念]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%89%8D%E7%AB%AF%2FHTML%2F01%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[学习平台菜鸟教程http://www.runoob.com本博文的内容多数来自书本和菜鸟教程，大家可前程该教程进行学习 什么是HTML?HTML 是用来描述网页的一种语言，又叫超文本标记语言，超文本指的是超链接，标记指的是标签 Html这种语言由一个个的标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm html文件用编辑器打开显示的是文本，可以用文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页 Web 浏览器Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。 HTML 网页结构下面是一个可视化的HTML页面结构：只有 区域 (白色部分) 才会在浏览器中显示。 html基本结构一个html的基本结构如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页显示内容 &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE&gt; 声明网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。&lt;!DOCTYPE&gt;声明有助于浏览器中正确显示网页。doctype 声明是不区分大小写的，以上方式是声明为HTML5 html 标签&lt;html&gt;标签和最后一行&lt;/html&gt;定义html文档的整体 &lt;html&gt;标签中的lang=“en”定义网页的语言为英文，定义成中文是lang=&quot;zh-CN&quot;,不定义也没什么影响，它一般作为分析统计用。 head 标签&lt;head&gt;标签里面负责对网页进行一些设置以及定义标题，设置包括定义网页的编码格式，外链css样式文件和javascript文件等，设置的内容不会显示在网页上，标题的内容会显示在标题栏 中文编码目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8。 body 标签 &lt;body&gt; 标签内编写网页上显示的内容。平时上网看到的网页中的内容绝大部分都是在这个标签中编写的 html文档规范xhtml制定了文档的编写规范，html5可部分遵守，也可全部遵守，看开发要求。 1、所有的标签必须小写 2、所有的属性必须用双引号括起来 3、所有标签必须闭合 4、img必须要加alt属性(对图片的描述) html标签特点html的标签大部分是成对出现的,少量是单个出现的，特定标签之间可以相互嵌套，嵌套就是指一个标签里面可以包含一个或多个其他的标签，包含的标签和父标签可以是同类型的，也可以是不同类型的： &lt;!-- 成对出现的标签 --&gt; &lt;body&gt;......&lt;/body&gt; &lt;p&gt;......&lt;/p&gt; &lt;div&gt;......&lt;/div&gt; &lt;b&gt;......&lt;/b&gt; &lt;!-- 单个出现的标签 --&gt; &lt;br /&gt; &lt;img src=&quot;...&quot; /&gt; &lt;input type=&quot;...&quot; /&gt; &lt;!-- 标签之间的嵌套 --&gt; &lt;p&gt; &lt;span&gt;...&lt;/span&gt; &lt;a href=&quot;...&quot;&gt;...&lt;/a&gt; &lt;/p&gt; &lt;div&gt; &lt;h3&gt;...&lt;/h3&gt; &lt;div&gt; &lt;span&gt;...&lt;/span&gt; &lt;p&gt;...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维导图学习方法]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%97%A5%E5%B8%B8%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F1%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[思维导图的运用，有助于我们进一步的认识大脑，并对储藏的信息进行提炼和重组。我们生活在一个互联网时代，每天接收着庞大的信息量，这样的思维方式无疑是学半功倍的一种方法。 思维导图学习法重点要素是：中心点、分支线、关键词以及个性标。这种方法对于学习者的逻辑性和全局性思维有很好的培养功能。 工具推荐:手机app，思维导图，电脑端用Xmind或百度脑图。]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西蒙学习方法]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%97%A5%E5%B8%B8%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F2%E8%A5%BF%E8%92%99%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[又名 “ 锥形学习法 ”，此法来源于诺贝尔经济学奖获得者西蒙教授提出的一个理论：“对于一个有一定基础的人来说，只要真正肯下功夫，在6个月内就可以掌握任何一门学问。”为了形象地说明，可以将西蒙学习法比做一把锥子。就像居里夫人所说，“知识的专一性像锥尖，精力的集中好比是锥子的作用力，时间的连续性好比是不停顿地使锥子往前钻进。” 西蒙学习法之所以高效的原理是在于，连续的长时间学习本身包涵对之前学习内容的应用，这样就省去了大量的复习时间。 小编就拿最简单的用烧开水这件事来做比喻，西蒙学习法就是连续的加热，所以热量散失的少;普通的间断学习是烧一会儿就停止加热，一段时间以后再继续加热，这样许多热量就白白散失了。持续烧水和间隙烧水，那当然是持续加热的效果要好了。 西蒙学习法的核心是：持续(连续性的时间投入)、专注(精神集中)、目标单一(以某一技能提升为目标)，烧水、外语学习可以作为西蒙学习法的经典例子，持续加热一下子把水烧开，一天学习10h，集中单一课程，短期内突破。比刻意练习亦少了学习区的概念和即时反馈原则。]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQ3R阅读方法]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%97%A5%E5%B8%B8%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F3SQ3R%E9%98%85%E8%AF%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SQ3R 阅读法的步骤通常是这样的： 第1步，Survey浏览，浏览并不是简单的翻翻看看，在浏览的过程中是要注意书籍/文章的重要信息，包括书名，前言，目录，标题、图表，概要等等。 第2步，Question提问，浏览的过程中不仅仅是看，更要提出问题，从书名、标题上就可以开始提问题，包括各章节承上启下的内容，一边浏览一边提问是有利于激发学习兴趣。 第3步，Read阅读，这一次就是要精读细读，要对重要的、难解的部分反复阅读，并且自己要深刻理解，这一步一定是要仔细认真。 第4步，Recite复述，当你阅读完了之后，把书本/文章合上，回忆内容，并且用自己的语言复述内容/知识。这一步可以结合第二个步骤提问一起来进行，看看自己开始的提问有没有得到正确的回答，来检验自己是否读懂了。 第5步，Review 复习，任何知识都是需要复习的。SQ3R 阅读法建议复习一般在复述的后一两天进行。这样做的好处是，可以重温已有的知识，也可以温故知新，从旧的知识里生出新的感悟。]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3W2H法]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%97%A5%E5%B8%B8%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F43W2H%E6%B3%95%2F</url>
    <content type="text"><![CDATA[What ：什么是XXX Who ：谁XXX Why ：为什么XXX How ：如何XXX How Continue：如何持续地XXX 举例：学习Python这门语言 What ：什么是Python Who ：谁在使用Python Why ：为什么使用Python How ：如何学习Python How Continue：如何持续地去提高Python]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量化计算]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%BA%9F%E5%BC%83%E5%8D%9A%E6%96%87%2F04%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[向量化计算是一种特殊的并行计算的方式，可以在同一时间执行多次操作，对不同的数据执行同样的一批指令 生成等差数列numpy.arange(start, end, step) start : 开始值 end : 结束值 step: 步长 四则运算规则：相同位置的数据进行运算，结果保留在相同的位置语法：s1 op s2注意：如果两个向量长度不一样，就会使用rep方法，将短的变量不断重复，直到和长的变量长度一致 向量计算的原则1：代码中尽可能避免显式的for循环2：过早的优化是魔鬼 生成一个小数的等差数列import numpy r = numpy.arange(0.1, 0.5, 0.01) print(r) 打印 [0.1 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.2 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.3 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.4 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49] 四则运算import numpy r = numpy.arange(0.1, 0.5, 0.01) r + r r - r r * r r / r r ** 5 r // r 其实算术运算都可以 数据长短不一import numpy r = numpy.arange(0.1, 0.5, 0.01) r = r+1 所谓的长短不一是因为，r里面有很多数，它会把1重复很多次，与r中的每一个数分别相加 比较运算import numpy r = numpy.arange(0.1, 0.5, 0.01) r &gt; 0.3 打印 array([False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]) 多数时用来过滤数据 r[r&gt;0.3] 打印 array([0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 , 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49]) 矩阵运算import numpy r = numpy.arange(0.1, 0.5, 0.01) numpy.dot(r, r.T) #等价于sum(r*r) 打印 4.013999999999998]]></content>
  </entry>
  <entry>
    <title><![CDATA[DataFrame数据框]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%BA%9F%E5%BC%83%E5%8D%9A%E6%96%87%2F03DataFrame%2F</url>
    <content type="text"><![CDATA[数据框是用来存储多行与多列的数据集合。数据框和office中的Excel表格很像 定义不自己定义索引from pandas import DataFrame df = DataFrame({&apos;age&apos;:[21, 22, 23], &apos;name&apos;:[&apos;KEN&apos;, &apos;John&apos;, &apos;Jimi&apos;]}) 内部显示 index age name 0 21 KEN 1 22 John 2 23 Jimi 自己定义索引from pandas import DataFrame df = DataFrame( data = {&apos;age&apos;:[21, 22, 23], &apos;name&apos;:[&apos;KEN&apos;, &apos;John&apos;, &apos;Jimi&apos;]}, index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;] ) 内部显示 index age name frist 21 KEN second 22 John third 23 Jimi 访问from pandas import DataFrame df = DataFrame( data = {&apos;age&apos;:[21, 22, 23], &apos;name&apos;:[&apos;KEN&apos;, &apos;John&apos;, &apos;Jimi&apos;]}, index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;] ) 按行访问df[1:2] 打印 age name second 22 John 按列访问df[&apos;age&apos;] 打印 frist 21 second 22 third 23 Name: age, dtype: int64 按行列号访问df.iloc[1, 1] 打印 &apos;John&apos; 增加from pandas import DataFrame df = DataFrame( data = {&apos;age&apos;:[21, 22, 23], &apos;name&apos;:[&apos;KEN&apos;, &apos;John&apos;, &apos;Jimi&apos;]}, index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;] ) 增加行df.loc[len(df)] = [24, &apos;Lili&apos;] 内部显示 index age name frist 21 KEN second 22 John third 23 Jimi 3 24 Lili 增加列df[&apos;grade&apos;] = [81, 55, 43, 77] 内部显示 index age name grade frist 21 KEN 81 second 22 John 55 third 23 Jimi 43 3 24 Lili 77 修改from pandas import DataFrame df = DataFrame( data = {&apos;age&apos;:[21, 22, 23], &apos;name&apos;:[&apos;KEN&apos;, &apos;John&apos;, &apos;Jimi&apos;]}, index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;] ) 修改行索引df.index = range(1, 4) 打印 age name 1 21 KEN 2 22 John 3 23 Jimi 注意:索引的个数一定要和元素的个数相等 修改列名df.columns = [&apos;age2&apos;, &apos;name2&apos;] 打印 age2 name2 1 21 KEN 2 22 John 3 23 Jimi 删除from pandas import DataFrame df = DataFrame( data = {&apos;age&apos;:[21, 22, 23], &apos;name&apos;:[&apos;KEN&apos;, &apos;John&apos;, &apos;Jimi&apos;]}, index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;] ) 根据索引删除一行df.drop(&apos;frist&apos;) 打印 age name second 22 John third 23 Jimi 根据列名删除一列df.drop(&apos;age&apos;, axis = 1) 打印 name frist KEN second John third Jimi 注意：用drop方法删除的数据需要接收 axis属性可以判断是删除行还是删除列，0删除行，1删除列，默认是0 del函数del dfp[&apos;age&apos;] 内部显示 index name frist KEN second John third Jimi 注意：del函数删除是列是不需要重新接收的，直接删除 遍历from pandas import DataFrame df = DataFrame( data = {&apos;age&apos;:[21, 22, 23], &apos;name&apos;:[&apos;KEN&apos;, &apos;John&apos;, &apos;Jimi&apos;]}, index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;] ) 遍历列名for column in df: print(column) 打印 age name 遍历列for column in df: print(&quot;列名：&quot;, column) print(&quot;值：\n&quot;, df[column]) 打印 列名： age 值： frist 21 second 22 third 23 Name: age, dtype: int64 列名： name 值： frist KEN second John third Jimi Name: name, dtype: object 遍历行for index, row in df.iterrows(): print(&quot;第&quot;, index, &quot;行&quot;) print(row) 打印 第 frist 行 age 21 name KEN Name: frist, dtype: object 第 second 行 age 22 name John Name: second, dtype: object 第 third 行 age 23 name Jimi Name: third, dtype: object]]></content>
  </entry>
  <entry>
    <title><![CDATA[Series系列]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%BA%9F%E5%BC%83%E5%8D%9A%E6%96%87%2F02Series%2F</url>
    <content type="text"><![CDATA[Pandas中有两种常用的数据结构 Series：系列 DataFrame：数据框 Series系列系列是用于存储一列或一行的数据，以及与之相关的索引的集合。系列与列表非常相像，只是多了一个索引的概念 定义1：自己不定义索引的系列 x = Series([&apos;a&apos;, &apos;True&apos;, 1]) #自己不定义索引的系列,索引默认从0开始 内部显示 index 0 0 a 1 True 2 1 2：自己定义索引的系列 x = Series([&apos;a&apos;, &apos;True&apos;, 1], index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;]) #索引从自己定义的开始 内部显示 index 0 frist a second True third 1 注：索引元素要一致，否则会报： ValueError: Length of passed values is 4, index implies 3 ValueError: Length of passed values is 3, index implies 4 追加系列不能直接追加元素 x = Series([&apos;a&apos;, &apos;True&apos;, 1], index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;]) x.append(&apos;2&apos;) 打印 TypeError: cannot concatenate object of type &quot;&lt;class &apos;str&apos;&gt;&quot;; only pd.Series, pd.DataFrame, and pd.Panel (deprecated) objs are valid 正确的追加方式 n = Series([&apos;n&apos;]) x = x.append(n) #新添加的系列要重新接收 z = Series([&apos;z&apos;]) x = x.append(z) 内部显示 index 0 frist a second True third 1 0 n 0 z #似乎自己不定义索引的话，默认追加后的索引是0 判断值是否存在1 in x # False 这是错误的做法 正确做法 1 in x.values #True 切片x[1:3] 删除x = x.drop(0) x = x.drop(&apos;frist&apos;) x = x.drop(&apos;2&apos; != x.values) x = x.drop(x.index[3]) 遍历x = Series([&apos;a&apos;, &apos;True&apos;, 1], index = [&apos;frist&apos;, &apos;second&apos;, &apos;third&apos;]) for index in x.index: print(&quot;索引：&quot;, index) print(&quot;值：&quot;, x[index]) 打印 索引： frist 值： a 索引： second 值： True 索引： third 值： 1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Anaconda的安装]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F00Anaconda%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[什么是Anaconda拥有超过600万用户，开源Anaconda Distribution是在Linux，Windows和Mac OS X上进行Python和R数据科学和机器学习的最快和最简单的方法。它是开发，测试和培训的行业标准。单机。 轻松安装1,400多个Python / R数据科学包并管理您的包，依赖项和环境 - 只需单击一下按钮即可。免费和开源。 安装数据分析工具Anaconda官网地址Windows上的安装教程注：如果对英文阅读有困难，建议安装谷歌浏览器，通过右击选择中文翻译 Linux上的安装教程学习资料推荐博客园 CSDN 等等]]></content>
      <categories>
        <category>Python数据分析</category>
      </categories>
      <tags>
        <tag>Python数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%BA%9F%E5%BC%83%E5%8D%9A%E6%96%87%2F01%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[赋值：将定义好的数据，传递给变量 变量：本义指其值可以改变的量，这里说的是数据赋值的对象，我们通过变量名来操作数据 举例 x = 10 y = x-7 z = &apos;string&apos; t = True 变量的命名规则变量名可以由字母、数字、下划线组成，但不能以数字开头 区分字母的大小写 不能与系统关键字重名 如： 有效标识符名称的例子有i、__my_name、name_23和a1b2_c3。 无效标识符名称的例子有2things、this is spaced out和my-name。 许多系统变量以下划线开头，所以最好不用下划线开头命名变量 数据类型逻辑型又叫布尔型，用于只有两种取值（真 or 假， 0 or 1， 开 or 关等）的场合 值 注释 True 真 False 假 运算规则运算符 注释 运算规则 &amp; 按位与 两个逻辑型数据中，有一个逻辑型数据为假，结果为假 | 按位或 两个逻辑型数据中，有一个逻辑型数据为真，结果为真 not 取反 取相反的值，真为假，假为真 关于数字间的逻辑比较请看python基础里面的运算符一章 数值型运算规则运算符 注释 运算规则 + 加 - 减 * 乘 / 除 % 求余 // 整除 只保留整数部分 ** 乘方 指数幂运算 注意a = 4.2 b = 2.1 print(a+b) 打印 6.300000000000001 小数的运算是浮点数的运算，精度会有一点点的偏差，每种编程语言都有这个问题，在Python中的解决方法 from decimal import Decimal a = Decimal(&apos;4.2&apos;) b = Decimal(&apos;2.1&apos;) print(a+b) 打印 6.3 字符型字符型数据代表了所有可定义的字符 定义方式：使用 ‘’ 或 “” 或 “”””””将其包含起来 &apos;hello world&apos; &quot;&quot;&quot; 床前明月光 疑是地上霜 &quot;&quot;&quot; 注意： &apos;&apos; 和 &quot;&quot;之间没有区别,&apos;&apos;&apos; &apos;&apos;&apos; 和 &quot;&quot;&quot; &quot;&quot;&quot;之间没有区别 &apos;&apos;表示单行字符串，&apos;&apos;&apos; &apos;&apos;&apos;可以表示多行字符串 转义字符使用反斜杠（\）+ 字符 可以表示特殊字符 如 \n、 \t等，具体有哪些特殊字符可以在前面的Python基础里的数据类型中或网上可以查到 print(&quot;hello \t world!&quot;) 原始字符如果不想使用反斜杠转义，可以在字符串前面加上一个 (r) 表示原始字符串 path = r&apos;C:\windows\python #注意末尾不能有反斜杠，否则会报错 续行符反斜杠还可以当做续行符，表示下一行是上一行的延续 s = &apos;abcdefg \ higklmn&apos; 多行符分号表示前面的语句是一个完整的语句，多个命令可以写在同一行 a = 4;b = 5; c = a+b; 当然，我不建议这样写 加号与乘号加号可以将两个字符串连接在一起，乘号可将字符串重复 s = &apos;abc&apos;+&apos;def&apos; st = &apos;abc&apos; * 3 print(s,st) 打印 &apos;abcdef&apos; &apos;abcabcabc&apos; ###字符串的索引Python中的索引方式有两种：一种是从左到右，从0开始依次增加；一种是从右到左，从-1开始依次减少 word = &apos;Python&apos; print(word[0], word[5]) print(word[-1], word[-6]) ###字符串的切片对字符串进行切片可以得到一段子串，截取的范围是左闭右开区间 s = &apos;helloworld&apos; print(s[1:5]) print(s[:]) print(s[5:]) print(s[:-1]) print(s[1:5:2]) 打印 ello helloworld world helloworl el 详细内容看Python基础里的切片知识 注：不能改变字符串里的内容 s = &apos;helloworld&apos; s[2] = &apos;a&apos; #error 检测开头和结尾S.endswith(suffix[, start[, end]]) -&gt; bool S.startswith(prefix[, start[, end]]) -&gt; bool 案例 Web = &apos;https://www.zylin.xyz&apos; Web.endswith(&apos;.xyz&apos;) #检测结尾，如果符合返回True Web.startswith(&apos;http:&apos;) #检测开头，如果符合返回True choices = (&apos;http:&apos;,&apos;https:&apos;) 注意，这仅能接受一个字符元组，不支持列表 Web.startswith(choices) #只要开头符合两者之一就返回True 查找字符串S.find(sub[, start[, end]]) -&gt; int 案例 Web = &apos;花木成畦手自栽 https://www.zylin.xyz https:开朗大方&apos; result = Web.find(&apos;https:&apos;) #从左至右查找字符，查找到返回字符的当前位置，查找不到返回-1 print(result) #打印 8 ，汉字算一个字符 result = Web.rfind(&apos;https:&apos;) #从右至左查找字符，和上面一样 print(result) #打印30 忽略大小写查找字符串findall(pattern, string, flags=0) -&gt; list 案例 import re #需要导入re包 Web = &apos;UPPER PYTHON, lower python, Mixed Python&apos; re.findall(&apos;python&apos;,Web, flags = re.IGNORECASE) #IGNORECASE是一个标志 打印 [&apos;PYTHON&apos;, &apos;python&apos;, &apos;Python&apos;] 想要详细了解需要学习Python的 正则表达式 替换字符串S.replace(old, new[, count]) -&gt; str #不写count参数则默认替换所有字符 案例 text = &apos;hello world,hello python, hello anaconda&apos; text.replace(&apos;hello&apos;,&apos;hi&apos;) 打印 &apos;hi world,hi python, hi anaconda&apos; 忽略大小写替换字符串sub(pattern, repl, string, count=0, flags=0) -&gt; str 案例 import re #需要导入re包 Web = &apos;UPPER PYTHON, lower python, Mixed Python&apos; re.sub(&apos;python&apos;, &apos;text&apos;,Web, flags = re.IGNORECASE) 打印 &apos;UPPER text, lower text, Mixed text&apos; 合并拼接字符串S.join(iterable) -&gt; str 案例 parts = [&apos;My&apos;, &apos;name&apos;, &apos;is&apos;, &apos;Zylin&apos;, &apos;and&apos;,&apos;I&apos;, &apos;am&apos;, &apos;a&apos;, &apos;student&apos;] &apos;&apos;.join(parts) &apos; &apos;.join(parts) &apos;,&apos;.join(parts) 打印 &apos;MynameisZylinandIamastudent&apos; &apos;My name is Zylin and I am a student&apos; &apos;My,name,is,Zylin,and,I,am,a,student&apos; 注数据结构请找到前面的元组、列表、字典、集合进行学习]]></content>
  </entry>
  <entry>
    <title><![CDATA[1002]]></title>
    <url>%2F2018%2F08%2F03%2F%E7%AE%97%E6%B3%95%2FACM%2F1002%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[内心有种深深的无力感，刚过渡了1001的水题以后，接下来直接面对了一题名叫Fire Net 1002这题。这难度真是，，好像前一秒在刷小学加减，后一秒题目就变成了高中习题。。。抱歉，是我太菜了，研究了一个多小时，唯一的发现就是需要某种搜索方法，大学听过老师讲过这个理念，广度搜索或者深度搜索之类的。。我还是看看算法书吧，，杭电后面几题也是这样的。。暂时就先不更ACM了]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001]]></title>
    <url>%2F2018%2F08%2F02%2F%E7%AE%97%E6%B3%95%2FACM%2F1001%2F</url>
    <content type="text"><![CDATA[注：目前所有题目都源于杭电ACM 题目：1001 C++语法#include&lt;iostream&gt; using namespace std; int main() { int a, b; while(cin &gt;&gt; a &gt;&gt; b) cout &lt;&lt; a+b &lt;&lt; endl; } Python2语法方式一while True: try: a, b = map(int, raw_input().strip().split()) print a + b except EOFError: break 方式二while True: try: caption = map(int, raw_input().split()) ans = 0 for i in caption: ans += i print ans except EOFError: break 方式三import sys for line in sys.stdin: a = line.split() print int(a[0]) + int(a[1]) python3语法 while True: try: caption = list(map(int, input().split())) #这里有不同 ans = 0 for i in caption: ans += i print(ans) #这里有不同 except EOFError: break]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM输入输出]]></title>
    <url>%2F2018%2F08%2F01%2F%E7%AE%97%E6%B3%95%2FACM%2F0ACM%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[从现在开始，除非遇到特别的紧要的事情，否则我会每天晚上抽出两个小时的时间用来做题，下面附上ACM的输入输出规则。 C和C++传送门python3传送门python2传送门注：题目解法大多用C语言来写，再用python3的语法来写一遍]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的魔法方法]]></title>
    <url>%2F2018%2F07%2F30%2Fpython%2Fpython%E4%B8%8A%2F32%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[返回一个对象的描述字符串str方法#返回一个对象的描述字符串, 更加方便用户阅读, 对用户更友好 触发方式 print 打印一个对象时 str() 函数时 格式 def __str__(self): return &quot;描述信息&quot; 举例 class Cat: &quot;&quot;&quot;定义一个Cat类&quot;&quot;&quot; #初始化对象 def __init__(self,new_name,new_age): self.name = new_name self.age = new_age def __str__(self): return &quot;%s的年龄是:%d&quot;%(self.name,self.age) tom = Cat(&quot;汤姆&quot;,40) lanmao = Cat(&quot;蓝猫&quot;,10) print(tom) print(lanmao) 打印 汤姆的年龄是:40 蓝猫的年龄是:10 当我们将str方法注释后,再运行代码对比下输出内容如下: &lt;__main__.Cat object at 0x7fbc0ca62198&gt; &lt;__main__.Cat object at 0x7fbc0ca62240&gt; 打印的是系统默认的表达格式. 总结当我们在调用print(类)时,系统会先查找str或者repr方法,如果有这两种方法的一个,则打印方法返回的值. repr方法#返回一个对象的描述字符串, 更加方便机器处理, 对机器更友好(开发人员查看) 触发方式 当我们在交互模式下, 直接执行对象名回车, 就会输出对应信息 通过调用repr()函数时 格式 def __repr__(self): return &quot;描述信息&quot; 注意 一般情况下, 应满足如下等式 obj == eval(repr(obj)) 如： 或者描述一个实例详细的信息(类名等等) 例一 class Cat: &quot;&quot;&quot;定义一个Cat类&quot;&quot;&quot; #初始化对象 def __init__(self,new_name,new_age): self.name = new_name self.age = new_age def __repr__(self): return &quot;%s的年龄是:%d&quot;%(self.name,self.age) tom = Cat(&quot;汤姆&quot;,40) lanmao = Cat(&quot;蓝猫&quot;,10) print(tom) print(lanmao) 打印 汤姆的年龄是:40 蓝猫的年龄是:10 例二 import datetime temp = datetime.datetime.now() print(temp) print(repr(temp)) result = repr(temp) print(eval(result)) 打印 2018-08-14 17:18:39.073666 datetime.datetime(2018, 8, 14, 17, 18, 39, 73666) 2018-08-14 17:18:39.073666 str 与 repr方法的区别案例 class Person: def __str__(self): return &quot;str&quot; def __repr__(self): return &quot;repr&quot; p = Person() print(p) print(repr(p)) 总结当一个类同时拥有str 和 repr方法时，print（类）打印的是__str__方法，可以利用repr()函数打印__repr__方法 __str__方法和__repr__方法都是返回一个对象的描述字符串, 但__str__更加方便用户阅读, 对用户更友好，__repr__更加方便机器处理, 对机器更友好 更多是利用repr方法返回的值，通过eval函数再次重新转换为一个具体的对象 使对象像函数一样可以被调用call方法作用 使得“对象”具备当做函数，来调用的能力 使用 1. 实现实例方法 __call__ 2. 那么创建好的实例, 就可以通过函数的形式来调用 实例(参数) 应用场景 有点类似于之前所讲的&quot;偏函数&quot;的应用场景 可以将&quot;常变参数&quot;和&quot;不常变参数&quot;进行分离 案例 不同类型的笔, 画不同的图形 class PenFactory(object): def __init__(self, p_type): self.type = p_type def __call__(self, p_color): print(&quot;创建了一个%s类型的画笔，画笔颜色是%s&quot; % (self.type, p_color)) pen = PenFactory(&quot;钢笔&quot;) pen(&quot;红色&quot;) pen(&quot;黄色&quot;) pen(&quot;绿色&quot;) 打印 创建了一个钢笔类型的画笔，画笔颜色是红色 创建了一个钢笔类型的画笔，画笔颜色是黄色 创建了一个钢笔类型的画笔，画笔颜色是绿色 使对象可以像字典一样操作设置元素的方法 def __setitem__(self, key, value): 获取元素的方法 def __getitem__(self, item): 删除元素的方法 def __delitem__(self, key): 案例 class Person(object): &quot;&quot;&quot;docstring for Person&quot;&quot;&quot; def __init__(self): self.dict = {} def __setitem__(self, key, value): self.dict[key] =value def __getitem__(self, item): return self.dict[item] def __delitem__(self, key): del self.dict[key] people = Person() people[&quot;name&quot;] = &quot;zylin&quot; print(people[&quot;name&quot;]) del people[&quot;name&quot;] print(people.dict) 打印 zylin {} 自定义对象比较规则相等 __eq__ 不相等 __ne__ 小于 __lt__ 小于或等于 __le__ 大于 __gt__ 大于或等于 __ge__ 案例： class Person(object): &quot;&quot;&quot;docstring for Person&quot;&quot;&quot; def __init__(self, age): self.age = age def __eq__(self, other): return self.age == other.age def __ne__(self, other): return self.age != other.age def __lt__(self, other): return self.age &lt; other.age def __le__(self, other): return self.age &lt;= other.age def __gt__(self, other): return self.age &gt; other.age def __ge__(self, other): return self.age &gt;= other.age xiao = Person(18) zylin = Person(22) print(&quot;==&quot;, xiao == zylin) print(&quot;!=&quot;, xiao != zylin) print(&quot;&lt; &quot;, xiao &lt; zylin) print(&quot;&gt; &quot;, xiao &gt; zylin) print(&quot;&lt;=&quot;, xiao &lt;= zylin) print(&quot;&gt;=&quot;, xiao &gt;= zylin) 注如果对于反向操作的比较符, 只定义了其中一个方法但使用的是另外一种比较运算那么, 解释器会采用调换参数的方式进行调用该方法 例如 定义了 &quot;小于&quot; 操作x &lt; y，使用 x &gt; y会被调换参数, 调用上面的 &quot;小于操作&quot; 但是, 不支持叠加操作 例如定义了 &quot;小于&quot; 和 &quot;等于&quot; 操作，不能使用 x &lt;= y 补充 使用装饰器, 自动生成”反向” “组合”的方法 步骤 1. 使用装饰器装饰类 @functools.total_ordering 2. 实现 &gt; 或 &gt;= 或 &lt; 或 &lt;= 其中一个 实现 == 上下文环境中的布尔值 __bool__]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的魔法属性]]></title>
    <url>%2F2018%2F07%2F28%2Fpython%2Fpython%E4%B8%8A%2F31%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AD%94%E6%B3%95%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[案例 class Animal(object): &quot;&quot;&quot; 这是一个动物类 &quot;&quot;&quot; age = 19 def __init__(self): self.name = &quot;Dog&quot; def run(self): print(&quot;run&quot;) dict属性#dict属性可以查看类和对象中有哪些属性 print(Animal.__dict__) #查看类属性 animal = Animal() print(animal.__dict__) #查看对象属性 打印 {&apos;__module__&apos;: &apos;__main__&apos;, &apos;age&apos;: 19, &apos;__init__&apos;: &lt;function Animal.__init__ at 0x02ED96F0&gt;, &apos;run&apos;: &lt;function Animal.run at 0x033564B0&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Animal&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Animal&apos; objects&gt;, &apos;__doc__&apos;: None} {&apos;name&apos;: &apos;Dog&apos;} bases属性#查看类的所有父类 print(&quot;Animal.__bases__&quot;) #只能查看类，不能查看对象 打印 (&lt;class &apos;object&apos;&gt;,) doc属性#查看类的文档 print(Animal__doc__) 打印 &apos;\n\t\t\t这是一个动物类\n\t\t&apos; 注：与help函数有区别，区别在于doc只打印自己写在三引号中的内容 module属性#查看类定义所在的模块 print(Animal.__module__) 打印 __main__ class属性 #查看实例对应的类 print(animal.__class__) 打印 &lt;class &apos;__main__.Animal&apos;&gt;]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典类与新式类]]></title>
    <url>%2F2018%2F07%2F28%2Fpython%2Fpython%E4%B8%8A%2F30%E7%BB%8F%E5%85%B8%E7%B1%BB%E4%B8%8E%E6%96%B0%E5%BC%8F%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[经典类与新式类的区别经典类没有继承object类，新式类继承了object类 继承搜索的顺序发生了改变，即经典类多继承搜索顺序(深度优先):先深入继承树左侧查找，然后再返回，开始查找右侧 新式类多继承搜索顺序(广度优先):先在水平方向查找，然后再向上查找 “新式类”和“经典类”的区分在Python 3之后就已经不存在，在Python 3.x之后的版本，因为所有的类都派生自内置类型object(即使没有显示的继承object类型)，即所有的类都是“新式类”。 查看方式 类名.__bases__ 如： Animal.__bases__ Python2.x版本定义一个类时, 默认不继承(object) Python3.x版本定义一个类时, 默认继承(object) 无论是python2 还是 Python3，建议使用新式类（尽管Python3没有经典类） 推荐写法: class 类名(object): pass]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[只读属性]]></title>
    <url>%2F2018%2F07%2F26%2Fpython%2Fpython%E4%B8%8A%2F29%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7%E4%B8%8Eproperty%2F</url>
    <content type="text"><![CDATA[只读属性只读的意思是只能读取不能写入 class Animal(Object): def __init__(self): self.__age = 5 animal = Animal() print(animal.__age) #报错 animal.__age = 18 #虽然不会报错，但并没有修改__age的值，而是在对象中新增一个属性,看下面 print(animal.__dict__) 打印 {&apos;_Animal__age : 5&apos;, &apos;__age : 18&apos;} 注意：直接animal.__age = 18不会报错，而是新增一个属性，这会给人一个假象，仿佛修改成功了，要谨慎。有些属性, 只限在内部根据不同场景进行修改, 而对外界来说, 只能读取。要做到只读取私有属性的方法有两种 方式一实现部分公开，部分公开的意思是封闭其他方法，再提供一个对外交流的接口，如在类内增加访问方法 class Animal(Object): def __init__(self): self.__age = 5 def getAge(self): return self.__age animal = Animal() print(animal.getAge()) 这样通过一个公开的方法就可以做到访问私有属性，但是有些麻烦，有没有更简单的办法呢 方式二在实现部分公开的基础上，增加一个装饰器，做到以使用属性的方式来使用这个方法 class Animal(Object): def __init__(self): self.__age = 5 @property def age(self): return self.__age animal = Animal() print(animal.age) #打印 5 如果想给__age赋值呢 animal.age = 18 答案是会直接报错，你不能设置这个属性 方式二的好处：一是可以以属性的方式来访问这个方法，二是避免了上面给人那种修改属性的假象 方式三使用setattr方法，略(详细请百度) property的介绍作用：将一些”属性的操作方法”关联到某一个属性中有两种使用方式 方式一使用property对象将属性的操作方法关联到属性上 class Animal(object): def __init__(self): self.__age = 2 def getAge(self): return self.__age def setAge(self, value): self.__age = value def delAge(self): del self.__age age = property(getAge,setAge,delAge) animal = Animal() print(animal.age) animal.age = 5 print(animal.__dict__) del animal.age print(animal.__dict__) 打印 2 {&apos;_Animal__age&apos;: 5} {} 方式二使用property装饰 class Animal(object): def __init__(self): self.__age = 2 @property def age(self): return self.__age @age.setter def age(self, value): self.__age = value @age.deleter def age(self): del self.__age animal = Animal() print(animal.age) animal.age = 5 print(animal.__dict__) del animal.age print(animal.__dict__) 注意：要想使用这种方式进行设置属性、删除属性，这样写的前提要求是，必须在前面写上property进行装饰后，才能写上 方法名.setter 这种进行设置属性 附： 在经典类中，只能管理一个属性的读取操作 在新式类中可以管理一个属性的删改查操作 后一章会简单的介绍经典类与新式类]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性的权限]]></title>
    <url>%2F2018%2F07%2F24%2Fpython%2Fpython%E4%B8%8A%2F28%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[属性的访问范围划分基类内 派生类内 模块内 跨模块访问 =======cls.py===================== class Animal: #基类内部 || pass || || class Dog(Animal):#派生类内(子类) || #跨模块访问 pass || || a = 6 #模块内部 || || ========temp.py=================== X = &quot;xyz&quot; 公有属性直接在类内添加的属性，外观和普通变量一样案例 ==============cls.py============ text = &quot;hello&quot; #这是一个全局变量 class Animal: age = 5 #这是一个公有属性 def prt(self): print(Animal.age) print(self.age) class Dog(Animal): def prt(self): print(Dog.age) print(self.age) #在基类中的访问权限 animal = Animal() animal.prt() #打印 5 5 #在派生类（子类）中的访问权限 dog = Dog() dog.prt() #打印 5 5 #在模块中的访问权限 print(Animal.age) print(dog.age) #打印 5 5 #跨模块访问 ===========temp.py========= import cls || from cls import * === 或者 ===&gt;&gt; print(cls.Animal.age) || print(Animal.age) print(cls.text) || print(text) #打印 5 hello 总结公有属性在 基类、子类、模块内、跨模块中都可以访问,全局变量也一样不受范围限制 受保护的属性在变量的前面添加一个下划线的称为受保护的属性案例 ==============cls.py============== _text = &quot;hello&quot; #这是一个受保护的变量 class Animal: _age = 5 #这是一个受保护的属性 def prt(self): print(Animal._age) print(self._age) class Dog(Animal): def prt(self): print(Dog._age) print(self._age) #在基类中的访问权限 animal = Animal() animal.prt() #打印 5 5 #在派生类（子类）中的访问权限 dog = Dog() dog.prt() #打印 5 5 #在模块中的访问权限 print(Animal._age) print(dog._age) #打印 5 5 #跨模块访问 ===========temp.py========= import cls || from cls import * === 或者 ===&gt;&gt; print(cls.Animal._age) || print(Animal._age) print(cls._text) || print(_text) #打印 #打印 5 Error 总结受保护的属性在 基类、子类中都可以访问； 但是在模块内访问会得到一个警告：正在试图访问一个受保护的属性； 跨模块访问有两种方式，第一种import的方式会得到一个和模块内访问一样的警告，第二种from方式会直接报错:没有_text这样的一个受保护的变量 具体情况还需要自行实验 附： 如果在被导入的模块cls.py中添加一个 __all__ 的变量，受保护的变量_a就可以被导入 __all__的意思是允许被导入的变量，把可以导入的变量全部添加到这个变量中，用双引号括起来，不同的变量间用逗号隔开 写法：__all__ = [&quot;_a&quot;] 私有属性在变量的前面添加两个下划线的称为私有属性案例 ==============cls.py============== __text = &quot;hello&quot; #这是一个受保护的变量 class Animal: __age = 5 #这是一个受保护的属性 def prt(self): print(Animal.__age) print(self.__age) class Dog(Animal): def prt(self): print(Dog.__age) print(self.__age) #在基类中的访问权限 animal = Animal() animal.prt() #打印 5 5 #在派生类（子类）中的访问权限 dog = Dog() dog.prt() #打印 Traceback (most recent call last): File &quot;G:\Temp\cls.py&quot;, line 20, in &lt;module&gt; dog.prt() File &quot;G:\Temp\cls.py&quot;, line 12, in prt print(Dog.__age) AttributeError: type object &apos;Dog&apos; has no attribute &apos;_Dog__age&apos; #在模块中的访问权限 print(Animal.__age) print(dog.__age) #打印 Traceback (most recent call last): File &quot;G:\Temp\cls.py&quot;, line 22, in &lt;module&gt; print(Animal.__age) AttributeError: type object &apos;Animal&apos; has no attribute &apos;__age&apos; #跨模块访问 ===========temp.py========= import cls || from cls import * ====或者 ==&gt;&gt; print(cls.Animal.__age) || print(Animal.__age) print(cls.__text) || print(__text) #打印 Traceback (most recent call last): File &quot;G:\Temp\temp.py&quot;, line 2, in &lt;module&gt; print(cls.Animal.__age) AttributeError: type object &apos;Animal&apos; has no attribute &apos;__age&apos; hello 总结私有属性在类中定义，就只可以在这个类中被调用 私有属性不可以在其子类中、类外和跨模块使用 私有变量在跨模块调用中，遵循单下划线的调用规则 具体情况还需要自行实验 私有属性的实现原理在python中并没有真正的私有化，但是可以使用下划线完成伪私有的功能真正的私有是不管通过什么样的方式都访问不了这个属性，而伪私有可以通过一些手段，访问到这个私有属性 python私有属性的实现原理通过名字重整机制：将两个下划线的属性(如__age)改为 _类名__属性(如_Dog__age)这种形式 目的 1：防止外界访问 2：防止被子类同名所覆盖 举例 #前面有个Animal类，访问方法 print(Animal._Animal__age) #可以这样访问，但不建议这种写法]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法]]></title>
    <url>%2F2018%2F07%2F22%2Fpython%2Fpython%E4%B8%8A%2F27%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法概念描述一个目标的行为动作。比如描述一个人怎样吃，怎样喝，怎样玩…和函数非常类似 都封装了一系列行为动作 都可以在被调用的之后，执行一系列行为动作 最主要的区别就是：调用方式的不同 方法的划分实例方法：默认第一个参数需要接收到一个实例 类方法 ：默认第一个参数需要接收到一个类 静态方法：第一个参数啥也不默认接收 注意 1. 划分的依据是：方法的第一个参数必须要接收的数据类型 2. 不管是哪一种类型的方法，都是存储在类当中；没有在实例当中的 3. 不同类型方法的调用方式不同。但不管怎么调，把握一个原则 不管是自己传递，还是解释器帮我们处理，最终要保证不同类型的方法第一个参数接收到的数据，是他们想要的类型 实例方法class Person: def run(self): pass 类调用：必须传递一个对象，因为实例方法要求呀 对象调用;不用手动传，解释器会默认把调用对象本身传递过去 注意；一般使用对象来调用 类方法是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了）能够通过实例对象和类对象去访问。 class Person: @classmethod def countPerson(cls): pass 类调用：不用手动传递第一个参数，会自动的把调用的类本身给传递过去 对象调用：不用手动传递第一个参数，会自动的把调用的对象对应的类给传递过去 注意：一般使用类来调用 举例 class People(object): country = &apos;china&apos; #类方法，用classmethod来进行修饰 @classmethod def getCountry(cls): return cls.country @classmethod def setCountry(cls,country): cls.country = country p = People() print (p.getCountry()) #可以用过实例对象引用 print (People.getCountry()) #可以通过类对象引用 People.setCountry(&apos;japan&apos;) #对类属性进行修改 print (People.getCountry()) #可以通过类对象引用 print (p.getCountry()) #可以用过实例对象引用 显示 china china japan japan 用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变 静态方法需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数 class People(object): country = &apos;china&apos; @staticmethod #静态方法 def getCountry(): return People.country print (People.getCountry()) 补充 函数和方法的区别 函数都是独立的个体，函数之间几乎没有共享的数据,方法有宿主 self代表调用的对象 总结从类方法和实例方法以及静态方法的定义形式 类方法的第一个参数是类对象cls，那么通过cls引用的必定是类对象的属性和方法； 而实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性 不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。 静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类对象来引用]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性]]></title>
    <url>%2F2018%2F07%2F20%2Fpython%2Fpython%E4%B8%8A%2F26%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[属性属性与变量的区别概念 变量是“可以改变的量” 属性是“属于某个对象的特性” 访问权限 变量：根据不同的位置，存在不同的访问权限 全局变量 局部变量 ... 属性：只能通过对象来进行访问 所以，必须先找到对象 对象也是通过变量名来引用；而既然是变量，也有对应的访问权限 对象属性增加对象属性 1. 直接通过对象，动态添加 对象.属性 = 值 2. 通过类的初始化方法（构造方法） __init__方法（前面有介绍） 访问对象的属性 一般访问 对象.属性 如果访问不到 会直接报错 需要记住错误提示 修改一个对象的属性 同新增一样；系统会自动识别，不存在则新增，存在则修改 对象.属性 = 值 删除一个对象的属性 del 对象.属性 补充： 查看对象的所有属性：对象.__dict__ 案例： class People(object): address = &apos;山东&apos; #类属性 def attribute(self): self.name = &apos;xiaowang&apos; #实例属性 self.age = 20 #实例属性 类属性类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本万物皆对象，类也是一个对象。比如，男孩boy的模板，对于具体的人来说它是“类”，但模板本身是也是一个具体的东西 增加类属性 方式1 类名.类属性 = 值 方式2 class Dog: dogCount = 0 查询类属性 通过类访问 类名.类属性 通过对象访问 对象.类属性 注意：为什么可以通过对象访问到类属性？答：和Python对象的属性查找机制有关，优先到对象自身去查找属性，找到则结束。如果没有找到则根据class找到对象对应的类，到这个类里面查找 修改类属性 通过类名改，语法如同给类增加一个属性的方式1，系统也会自动检测，不存在，则新增；存在，则修改 类名.属性 = 值 案例： class People(object): name = &apos;Tom&apos; #公有的类属性 print(People.name) 注意：能否通过对象修改类属性？不能！ class People(object): country = &apos;china&apos; #类属性 print(People.country) p = People() print(p.country) p.country = &apos;japan&apos; print(p.country) #实例属性会屏蔽掉同名的类属性 print(People.country) del p.country #删除实例属性 print(p.country) 输出 china china japan china china 总结 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。 如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性 并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。 删除类属性 通过类名删除 del 类名.属性 能否通过对象删除？答案是不能！del 语句只删除直系属性 注意：类属性的内存存储问题 一般情况下，属性存储在__dict__的字典当中，有些内置对象没有这个__dict__属性，一般对象可以直接修改__dict__属性 但类对象的__dict__为只读；默认无法修改，但还是可以通过setattr方法修改 类属性被各个对象共享，类属性修改之后，所有的对象访问到的类属性都会跟着修改 补充 查看一个类的所有属性 类名.__dict__ 对象属性和类属性之间的区别存储不同，抽象层级不同，宿主不同 例如 类 class Person: count = 1 对象 p = Person() 问：p.count += 1，代码执行之后Person.count 与 p.count 打印的结果分别是多少？ 魔法方法slots功能：限制对象的属性 通过设置类属性： 这个属性是一个列表 列表中的元素，即为通过这个类创建出的对象可以添加的对象属性 如果这个类实例出的对象，添加了非列表之内的属性，则会报错 举例 class Person: __slots__ = [&quot;age&quot;] pass p1 = Person() p1.age = 1 p1.num = 2 结果 Traceback (most recent call last): File &quot;&lt;pyshell#7&gt;&quot;, line 1, in &lt;module&gt; p1.num = 2 AttributeError: &apos;Person&apos; object has no attribute &apos;num&apos;]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__init__方法]]></title>
    <url>%2F2018%2F07%2F19%2Fpython%2Fpython%E4%B8%8A%2F25__init__%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 init() 的特殊方法（构造方法），像下面这样： # 定义汽车类 class Car: def __init__(self): self.wheelNum = 4 self.color = &apos;蓝色&apos; def move(self): print(&apos;开车中&apos;) # 创建对象 BMW = Car() print(&apos;车的颜色为:%s&apos;%BMW.color) print(&apos;车轮胎数量为:%d&apos;%BMW.wheelNum) 创建一个新的实例: x = Car() 当创建Car对象后，BMW就默认拥有了2个属性wheelNum和color，类定义了 init() 方法的话，类的实例化操作会自动调用 init() 方法。 当然， init() 方法可以有参数，参数通过 init() 传递到类的实例化操作上。例如: class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5) print(x.r, x.i) # 输出结果：3.0 -4.5 总结__init__()方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中，默认有1个参数名字为self 如果在创建对象时传递了2个实参，那么__init__(self)中出了self作为第一个形参外还需要2个形参，例如__init__(self,x,y) __init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[self]]></title>
    <url>%2F2018%2F07%2F18%2Fpython%2Fpython%E4%B8%8A%2F24self%2F</url>
    <content type="text"><![CDATA[类方法与普通的函数有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 class Test: def prt(self): print(self) print(self.__class__) p = Test() p.prt() 执行结果为： &lt;__main__.Test instance at 0x100771878&gt; __main__.Test 从执行结果可以看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。self 不是 python 关键字，我们把他换成 其他字符 也是可以正常执行的: class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test() 总结所谓的self，就是对象自身的意思，某个对象调用其方法时，是把这个对象作为第一个参数传递给self 我们在定义类方法时，按语法规定写上self即可 在调用其方法时，忽略传入self（系统自动传递）我们只需要传递后面的参数即可 self不是关键字，也可以为其他字符，只是大家都习惯用self，所以我们也用self，包括后面将要介绍的cls也一样]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定义类和创建对象]]></title>
    <url>%2F2018%2F07%2F17%2Fpython%2Fpython%E4%B8%8A%2F23%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%92%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[定义类定义一个类，格式如下： class 类名: 方法列表 eg: class Car: # 方法 def getCarInfo(self): print(&apos;车轮子个数:%d, 颜色%s&apos;%(self.wheelNum, self.color)) def move(self): print(&quot;车正在移动...&quot;) 说明：定义类时有2种：新式类和经典类，上面的Car为经典类，如果是Car(object)则为新式类,根据有无括号判断类名 的命名规则按照”大驼峰”（前面第4章基础知识有说到） 创建对象通过上面，定义了一个Car类；就好比画出有关于车的一张图纸，那么接下来就应该把图纸交给生成工人们去生成了 python中，可以根据已经定义的类去创建出一个个对象，创建对象的格式为: 对象名 = 类名() 举例： # 定义类 class Car: # 移动方法 def move(self): print(&apos;车在奔跑...&apos;) # 鸣笛方法 def toot(self): print(&quot;车在鸣笛...嘟嘟..&quot;) BMW = Car() # 创建一个对象，并用变量BMW来保存它的引用 BMW.color = &apos;黑色&apos; #给对象添加属性 BMW.wheelNum = 4 #轮子数量 BMW.move() #调用对象的方法 BMW.toot() print(BMW.color) print(BMW.wheelNum) BMW = Car()，这样就产生了一个Car的实例对象，此时也可以通过实例对象BMW来访问属性或者方法第一次使用BMW.color = ‘黑色’表示给BMW这个对象添加属性，如果后面再次出现BMW.color = xxx表示对属性进行修改BMW是一个对象，它拥有属性（数据）和方法（函数）当创建一个对象时，就是用一个模子，来制造一个实物 根据类创建对象流程BMW = Car() 执行流程 1. 类的定义 2. 根据类，创建出一个对象 3. 将对象的唯一标识返回]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费曼学习方法]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%97%A5%E5%B8%B8%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F0%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第一个要介绍的是一个顶尖的学习方法：就是一个标题上的费曼学习法(图：费曼本人) 先看看关于学习的分类有两种：一种是主动学习，一种是被动学习，这涉及到哈佛大学的学习吸收率金字塔 可以看到，主动学习与被动学习的差距。而费曼学习法的原理，就是如何将别人的知识转化为自己的知识的过程,下面附上费曼学习法的流程图： 具体步骤，很简单，就三步： 确定学习目标 模拟教学学习法 简化 在预习、复习的过程中，遇到一个重要的、从没见过的新术语新概念跳出来了。拿出一张白纸，在页顶记下它，这是你想要学习的概念。 图中还有一个没有提到的要点——反思。反思你在思考的时候在哪里卡了壳，着重这个地方，再次理解。这个过程也是至关重要! 费曼学习法可以考量自己对一个概念或知识是否理解，一个最直观的方法就是讲给别人听，如果能够用简洁清晰的语言让别人完全听懂你在说什么，就证明你完全了解所学的概念;反之则还需要再去认真学习。]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2F2018%2F07%2F15%2Fpython%2Fpython%E4%B8%8A%2F22%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[[4]: 面向过程&amp;面向对象面向过程：关注的是解决问题的每一个步骤 面向对象：关注的是解决问题所需要的对象 注：都是一种解决问题的思想，但面向对象本身就是对面向过程的封装 对象对象是一个具体的物体，是类的一个实例，这个物体有两个部分：状态和行为 状态定义对象当前的基本特征，行为是对象的一系列活动。 例：一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类物以类聚 人以群分 类是具有相同属性和行为事物的统称 类是建立对象的模型或蓝图，是抽象的概念，如图girl与boy是一个抽象的概念，具体的人是一个实例(对象) 如下图，爱心鸡蛋的模具是一个类 爱心鸡蛋是一个具体的对象 例如：下面有一个这样的狗属性 名字：二哈，性别：男，年龄：5，品种：中华田园犬 行为 叫 、跑、摇尾巴 根据上面的实例对象抽象出的类 犬 属性：名字，性别，年龄，品种 行为：叫 、跑、摇尾巴 然后根据上面抽象出的类而实例出几个对象 胖虎：不同的品种，颜色和行为等 二狗：不同的品种，颜色和行为等 董泰迪：不同的品种，颜色和行为等 类是图纸，而对象是根据图纸建的一个个实例。 类的构成类(Class) 由3个部分构成 类名 属性 方法 以上属性和方法，都是抽象的概念，在产生对象之后，对象才拥有具体的属性值，和方法实现 总结类就是创建对象的模板 由一个类可以派生出多个对象 拥有相同(或者类似)属性和行为的对象都可以抽像出一个类]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2018%2F07%2F13%2Fpython%2Fpython%E4%B8%8A%2F21%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[使用文件的目的就是把一些数据存储起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力 操作文件过程在操作文件的整体过程与使用word编写一份简历的过程是很相似的 1：打开文件，或者新建立一个文件 2：读/写数据 3：关闭文件 相对路径与绝对路径相对路径：在Python中，源代码的路径就是相对路径。 绝对路径：文件在物理磁盘上的路径 文件的打开通过open函数打开格式 open(&quot;文件路径&quot;, &quot;模式&quot;) 返回值：文件对象 f = open(&quot;temp.txt&quot;, &quot;w&quot;) 注：模式 关闭文件close()方法为什么要关闭：可以释放系统资源，会立即清空缓冲区的数据内容回写到磁盘文件 # 新建一个文件，文件名为:test.txt f = open(&apos;test.txt&apos;, &apos;w&apos;) # 关闭这个文件 f.close() 附：flush()方法可以立即刷新缓冲区中的内容并写入到磁盘 文件的读写写数据write()方法返回值：写入的字节长度 # 新建一个文件，文件名为:test.txt f = open(&apos;test.txt&apos;, &apos;w&apos;) # 写入数据 f.write(&quot;hello world&quot;) # 关闭这个文件 f.close() 读数据read方法格式 文件对象.read(字节数) 功能：==字节数表示要从文件中读取的数据的长度，如果没有传入num，那么就表示读取文件中所有的数据。==文件指针会向右移动 字节数 test.txt中的内容：hello world , i&apos;m here. f = open(&apos;test.txt&apos;, &apos;r&apos;) string = f.read(5) print(string) string = f.read() print(string) f.close() 输出 hello world, i&apos;m here. 注==如果open是打开一个文件，那么可以不用写打开的模式，即只写 open(‘test.txt’)，默认模式’r’==如果使用读了多次，那么后面读取的数据是从上次读完后的位置开始的 readline方法格式 文件对象.readline([limit]) 功能：==读取一行==limit是限制一行最大字符数 f = open(&apos;test.txt&apos;, &apos;r&apos;) string = f.readline(5) while string: print(string) string = f.readline(5) f.close() readlines方法格式 文件对象.readlines() 功能:自动按换行符处理，将处理好的每行组成一个列表，返回这个列表 f = open(&apos;test.txt&apos;, &apos;r&apos;) content = f.readlines() i=1 for temp in content: print(&quot;%d:%s&quot;%(i, temp)) i+=1 f.close() 输出 1:hello world, i&apos;m here 2:hello world, i&apos;m here 3:hello world, i&apos;m here 4:hello world, i&apos;m here 5:hello world, i&apos;m here 附：思考一下，如果一个文件很大，比如25G，结合自己的内存，试想应该怎样把文件的数据读取到内存然后进行处理呢？ 文件的定位读写获取当前读写的位置在读写文件的过程中，如果想知道当前的位置，可以使用tell()来获取格式 文件对象.tell() 返回值：当前文件位置 # 打开一个已经存在的文件 f = open(&quot;test.txt&quot;, &quot;r&quot;) str = f.read(3) position = f.tell() print(&quot;当前文件位置 : &quot;, position) str = f.read(3) print(&quot;读取的数据是 : &quot;, str) position = f.tell() print(&quot;当前文件位置 : &quot;, position) f.close() 定位到某个位置如果在读写文件的过程中，需要从另外一个位置进行操作的话，可以使用seek()格式 文件对象.seek(偏移量, [0|1|2]) 0:表示文件开头 1:表示当前位置 2:表示文件末尾 注：1和2只能用于二进制文件，不能用于文本文件 文件的相关操作有些时候，需要对文件进行重命名、删除等一些操作，在python中使用需要导入os模块 文件重命名格式 os.rename(src, dst) os.rename(&quot;a.txt&quot;, &quot;a123.txt&quot;) 作用：将src重命名为dst。rename不可以修改树状目录结构里的文件或目录 os.renames(old, new) os.renames(&quot;one/a.txt&quot;, &quot;two/b.txt&quot;) 作用：可以修改树状目录结构文件或目录 创建文件夹import os os.mkdir(&quot;张三&quot;) 删除文件格式 remove(待删除的文件名) 举例 import os os.remove(&quot;毕业论文.txt&quot;) 删除目录os.rmdir(path) 不能递归删除目录，如果文件夹非空会报错 os.removedirs(path) 递归删除目录，如果文件夹非空会报错附：递归删除是指如果文件夹中有子文件夹，removedirs可以删除 而rmdir不可以 获取当前目录import os os.getcwd() 改变默认目录os.chdir(&quot;目标目录&quot;) 获取目录内容列表os.listdir(&quot;文件名&quot;) 使用文件名可以获取指定目录中的内容 &quot;./&quot; 获取当前目录中所有内容 &quot;../&quot;获取当前目录上一级目录中所有内容 判断文件/文件夹是否存在os.path.exists(&quot;文件名/文件夹名&quot;) 其实这种方法还是有个问题，假设你想检查文件“test_data”是否存在，但是当前路径下有叫“test_data”的文件夹，这样就可能出现误判。 只检查文件是否存在os.path.isfile(&quot;文件名&quot;) 不存在将返回False 判断文件是否可做读写操作os.access(path, mode) path为文件路径，mode为操作模式，mode有几种: os.F_OK: 测试path是否存在。 os.R_OK: 测试path是否可读。 os.W_OK 测试path是否可写。 os.X_OK 测试path是否可执行。 该方法通过判断文件路径是否存在和各种访问模式的权限返回True或者False。 import os if os.access(&quot;/file/path/foo.txt&quot;, os.F_OK): print(&quot;Given file path is exist.&quot;) 判断是文件夹os.path.isdir(path) 判断是文件os.path.isfile(path)]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量作用域]]></title>
    <url>%2F2018%2F07%2F12%2Fpython%2Fpython%E4%B8%8A%2F20%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[变量的作用域是指 变量的作用范围。Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。 Python的作用域一共有4种(LEGB)L （Local） 局部作用域(函数内) E （Enclosing)闭包函数外的函数(闭包) G （Global） 全局作用域(当前的模块) B （Built-in） 内建作用域(所有模块) 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。注：在Python中没有块级作用域(if/while)，有其它语言基础的要注意 实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。 &gt;&gt;&gt;if true: msg = &quot;hello world&quot; &gt;&gt;&gt;msg &quot;hello world&quot; 如果将 msg 定义在函数中，则它就是局部变量，外部不能访问 &gt;&gt;&gt; def text(): msg = &quot;hello world&quot; &gt;&gt;&gt; msg Traceback (most recent call last): File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt; msg NameError: name &apos;msg&apos; is not defined 从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。 全局变量和局部变量局部变量：定义在函数内的变量，拥有一个局部作用域 全局变量：定义在函数外的变量，拥有一个全局作用域 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例： total = 0 # 这是一个全局变量 # 可写函数说明 def sum( arg1, arg2 ): #返回2个参数的和.&quot; total = arg1 + arg2 # total在这里是局部变量. print (&quot;函数内是局部变量 : &quot;, total) return total #调用sum函数 sum( 10, 20 ) print (&quot;函数外是全局变量 : &quot;, total) 查看局部变量函数:locals()，查看全局变量函数：globals() #global 和 nonlocal关键字#当内部作用域想修改外部作用域的变量时，就要用global和nonlocal关键字了。 num = 1 def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num) fun1() 在函数内修改全局变量使用global关键字如果要修改嵌套作用域（闭包）则需要 nonlocal 关键字了，如下实例 def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num) outer() 有一种特殊情况，假设这段代码被运行错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。 a = 10 def test(): a = a + 1 print(a) test() Traceback (most recent call last): File &quot;test.py&quot;, line 7, in &lt;module&gt; test() File &quot;test.py&quot;, line 5, in test a = a + 1 UnboundLocalError: local variable &apos;a&apos; referenced before assignment 附：为了便于阅读、规范化，所有的全局变量应该放在代码最上面]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可更改对象与不可更改对象]]></title>
    <url>%2F2018%2F07%2F11%2Fpython%2Fpython%E4%B8%8A%2F19%E5%8F%AF%E6%9B%B4%E6%94%B9%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%94%B9%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递不可变类型类似 c++ 的值传递，如 整数、字符串、元组等。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。注意：在python中只有按引用传递，唯一不同的地方是，传递的是可变对象和不可变对象。传递可变对象可改变数据，传递不可变对象，重新创建新数据。 python 传不可变对象实例def changeInt(a): a = 10 b = 2 changeInt(b) print(b) #结果是2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 a，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传可变对象实例可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如 def changeList(li): &quot;修改传入的列表&quot; li.append([1, 2, 3, 4]) print(&quot;函数内：&quot;, li) lis = [11, 22, 33] changeList(lis) print(&quot;函数外：&quot;, lis) 函数内：[11, 22, 33, [1, 2, 3, 4]] 函数外：[11, 22, 33, [1, 2, 3, 4]]]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序表]]></title>
    <url>%2F2018%2F07%2F10%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F1%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[根据线性表的实际存储方式，分为两种实现模型 顺序表 将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。 链表 将元素存放在通过链接构造起来的一系列存储块中。 顺序表顺序表的基本形式数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址加上逻辑地址与存储单元大小的乘积计算得到]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识]]></title>
    <url>%2F2018%2F07%2F10%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[什么是算法？解决特定问题的方法 为何要学习算法？&emsp;&emsp;从上面知道了算法就是解决特定问题的方法，而我们用的编程语言是用来解决问题的工具，工具有了，如何去使用工具才是我们应该要去学习的。如果说编程语言是利器，那么算法就是灵魂。算法很难，但也需要我们去学习。 什么是数据结构？数据结构是计算机存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。 算法与数据结构的区别程序 = 数据结构 + 算法总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体 算法的特性：* 有限的 * 每一步是明确的(不能有歧义) * 至少有一个输出 什么是好的算法？分析指标： * 空间复杂度S(n)：程序执行时占用存储单元的长度 * 时间复杂度T(n)：程序执行时耗费时间的长度 注：这两个指标与要处理的数据规模是相关的。 分析算法关注两种复杂度 * 最坏情况复杂度Tworst(n) * 平均情况复杂度Tavg(n) 不同复杂度的函数，在不同的数据规模下的增长趋势。 算法时间复杂度的计算点击链接学习 ：算法时间复杂度的计算 时间复杂度的几条基本计算规则基本操作，即只有常数项，认为其时间复杂度为O(1) 顺序结构，时间复杂度按加法进行计算 循环结构，时间复杂度按乘法进行计算 分支结构，时间复杂度取最大值 判断一个算法的效率时，只需要关注操作数量的最高次项，其它次要项和常数项可以忽略 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度 若两段算法分别有复杂度T1(n) = O(f1(n)) 和 T2(n) = O(f2(n))，则: 两个算法拼在一起时，等于两段的和 T1(n) + T2(n) 两个算法嵌套时，等于两段的积 T1(n) * T2(n) 抽象数据类型(ADT)抽象数据类型(Abstract Data Type)的含义是指一个数学模型以及定义在此数学模型上的一组操作。即把数据类型和数据类型上的运算捆在一起，进行封装。引入抽象数据类型的目的是把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。 最常用的数据运算有五种插入 修改 删除 查找 排序 案例一：写程序,计算给定多项式在定点x处的值 算法一上面写法不推荐 算法二&emsp;&emsp;秦九韶算法是中国南宋时期的数学家秦九韶提出的一种多项式简化算法。在西方被称作霍纳算法。是一种将一元n次多项式的求值问题转化为n个一次式的算法。其大大简化了计算过程，即使在现代，利用计算机解决多项式的求值问题时，霍纳规则依然是最优的算法规则。具体计算过程自行百度。 f(x) = A0 + X (A1 + X( … ( An - 1 + X( An ) ) ) ) 自行验证第一种与第二种时间复杂度，运行效率自行测试 案例二：给定N个整数的序列{A1,A2,……,An}，求下面函数的最大值。 算法一 算法二 算法三：分治思想 注：代码比较复杂，这里不展示，过程就是利用分治思想解决这个问题(分治思想后面会说) 算法四：在线处理“在线”指每输入一个数据进行即时处理，在任何一个地方终止，算法都能给出正解。]]></content>
      <categories>
        <category>算法基础</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[返回多个值]]></title>
    <url>%2F2018%2F07%2F10%2Fpython%2Fpython%E4%B8%8A%2F18%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[return语句return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标： import math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。 然后，我们就可以同时获得返回值： &gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print(x, y) 151.96152422706632 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： &gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6) &gt;&gt;&gt; print(r) (151.96152422706632, 70.0) 原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便，当然，你也可以用列表、字典来返回数据。 小结定义函数时，需要确定函数名和参数个数；如果有必要，可以先对参数的数据类型做检查；函数体内部可以用return随时返回函数结果；函数执行完毕也没有return语句时，自动return None。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2018%2F06%2F30%2Fpython%2Fpython%E4%B8%8A%2F17%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[为何要使用函数我们知道圆的面积计算公式为：S = πr2当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 xx不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。这时候，函数的好处就体现出来了,将上面语句改写为一个函数，函数area只需要写一次就可以多次调用。 函数的作用方便代码的重用 分解任务，简化程序逻辑 使代码模块化 抽象抽象是数学中非常常见的概念。举个例子计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作 这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原 成低级的加法运算。而且，这种抽象记法是可扩展的，比如： 还原成加法运算就变成了：(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。 函数定义和调用函数的定义在Python中，定义一个函数要使用def语句，函数定义好后需要调用才能使用这个语句。格式 def 函数名(): 代码 eg: def temp(): print(&quot;hello world&quot;) 函数的调用定义了函数之后，想要让这些代码能够执行，需要调用它调用函数很简单的，通过 函数名() 即可完成调用 temp() 函数的文档说明&gt;&gt;&gt; def test(a,b): ... &quot;用来完成对2个数求和&quot; ... print(&quot;%d&quot;%(a+b)) ... &gt;&gt;&gt; &gt;&gt;&gt; test(11,22) 33 如果执行，以下代码 &gt;&gt;&gt; help(test) 能够看到test函数的相关说明 Help on function test in module __main__: test(a, b) 用来完成对2个数求和 (END) 函数参数空函数如果想定义一个什么事也不做的空函数，可以用pass语句： def temp(): pass pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 注：如果只定义了函数，没写函数体，缺少了pass，代码运行就会有语法错误。 无参函数没有传递参数的函数 def han(): print(&apos;adfa&apos;) 单个参数在函数体中，可以以变量的方式使用该参数函数的调用：函数名(参数值) def printNumber(num): print(num) printNumber(5) #调用带有参数的函数时，需要在小括号中，传递数据 形参和实参的概念形参：上面函数定义中的参数num就是形参实参：在调用函数的时候，传递的参数5就是实参 多个参数def 函数名(参数1， 参数2， 参数3 ……): 函数体 函数名(参数1， 参数2， 参数3 ……) eg def sumNum(n1, n2, n3): print(n1+n2+n3) sumNum(1, 2, 3) 6 必需参数必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。调用printme()函数，你必须传入一个参数，不然会出现语法错误： def printStr(str): &quot;打印传入的字符串&quot; print(str) return printStr() Traceback (most recent call last): File &quot;&lt;pyshell#2&gt;&quot;, line 1, in &lt;module&gt; printStr() TypeError: printStr() missing 1 required positional argument: &apos;str&apos; 关键字参数关键字参数和函数调用关系紧密，函数调用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。以下实例在函数 printme() 调用时使用参数名： def printStr(str): print(str) return printStr(str = &quot;hello world&quot;) def printPerson(name, age): &quot;打印传入的姓名和年龄&quot; print(&quot;姓名：&quot;, name) print(&quot;年龄：&quot;, age) printPerson(age = 50, name = &quot;zylin&quot;) 默认参数调用函数时，如果没有传递参数，则会使用默认参数。下边实例中如果没有传入 age 参数，则使用默认值 def printPerson(name, age = 15): &quot;打印传入的姓名和年龄&quot; print(&quot;姓名：&quot;, name) print(&quot;年龄：&quot;, age) printPerson(&quot;zylin&quot;) 姓名：zylin 年龄：15 注：默认参数必须放在最后面，否则为报错 def printPerson(age = 15, name): #注意观察这里 &quot;打印传入的姓名和年龄&quot; print(&quot;姓名：&quot;, name) print(&quot;年龄：&quot;, age) SyntaxError: non-default argument follows default argument 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下： def functionname([args,] *args_tuple): function_suite return [expression] 加星号(*)的变量名会存放所有未命名的变量参数。参数类型是元组。 def printPerson(name, age, *args): &quot;打印传入的姓名和年龄&quot; print(&quot;姓名：&quot;, name) print(&quot;年龄：&quot;, age) print(&quot;args:&quot;, args) printPerson(&quot;zylin&quot;, 22, &quot;安徽省&quot;, &quot;男&quot;, 18012345678) 姓名： zylin 年龄： 22 args: (&apos;安徽省&apos;, &apos;男&apos;, 18012345678) 加两个星号(**)的变量名会存放所有未命名的变量参数。参数类型是字典。 def printPerson(name, age, **args): &quot;打印传入的姓名和年龄&quot; print(&quot;姓名：&quot;, name) print(&quot;年龄：&quot;, age) print(&quot;args:&quot;, args) printPerson(&quot;zylin&quot;, 22, 地址=&quot;安徽省&quot;, 性别=&quot;男&quot;, 电话=18012345678) 姓名： zylin 年龄： 22 args: {&apos;地址&apos;: &apos;安徽省&apos;, &apos;性别&apos;: &apos;男&apos;, &apos;电话&apos;: 18012345678} 参数拆/装包装包：把传递的参数，包装成一个列表/集合等的操作，称为装包 eg: def temp(*args) #定义一个函数的参数时，使用*args称为装包 拆包：把集合等参数，再次分解成单独的个体，称为拆包 eg: temp(*args) #调用一个函数时，使用*args称为拆包 注：也可以使用**args字典来拆/装包 匿名函数所谓匿名，是指没有名字(函数名)的函数。格式： lambda 参数1, 参数2, ……:表达式 ambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。lambda 函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,.....argn]]:expression 参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError： &gt;&gt;&gt; my_abs(1, 2) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: my_abs() takes 1 positional argument but 2 were given 但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别 错误和异常处理将在后续讲到。这里了解下就好]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三大结构]]></title>
    <url>%2F2018%2F06%2F28%2Fpython%2Fpython%E4%B8%8A%2F16%E4%B8%89%E5%A4%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[条件判断计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。 也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了： age = 3 if age &gt;= 18: print(&apos;your age is&apos;, age) else: print(&apos;your age is&apos;, age) 注意不要少写了冒号:。 当然上面的判断是很粗略的，完全可以用elif做更细致的判断： age = 3 if age &gt;= 18: print(&apos;adult&apos;) elif age &gt;= 6: print(&apos;teenager&apos;) else: print(&apos;kid&apos;) elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是： if &lt;条件判断1&gt;: &lt;执行1&gt; elif &lt;条件判断2&gt;: &lt;执行2&gt; elif &lt;条件判断3&gt;: &lt;执行3&gt; else: &lt;执行4&gt; if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager： age = 20 if age &gt;= 6: print(&apos;teenager&apos;) elif age &gt;= 18: print(&apos;adult&apos;) else: print(&apos;kid&apos;) if判断条件还可以简写，比如写： if x: print(&apos;True&apos;) 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。 再议 input最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思： birth = input(&apos;birth: &apos;) if birth &lt; 2000: print(&apos;00前&apos;) else: print(&apos;00后&apos;) 输入1982，结果报错： Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: unorderable types: str() &gt; int() 这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情： s = input(&apos;birth: &apos;) birth = int(s) if birth &lt; 2000: print(&apos;00前&apos;) else: print(&apos;00后&apos;) 再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息： Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; ValueError: invalid literal for int() with base 10: &apos;abc&apos; 原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。 练习小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：低于18.5：过轻 18.5-25：正常 25-28：过重28-32：肥胖 高于32：严重肥胖 循环要计算1+2+3，我们可以直接写表达式： &gt;&gt;&gt; 1 + 2 + 3 6 要计算1+2+3+…+10，勉强也能写出来。但是，要计算1+2+3+…+10000，直接写表达式就不可能了。 为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。这种利用循环完成重复运算的操作，我们将其称为迭代 for循环Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子 names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] for name in names: print(name) 执行这段代码，会依次打印names的每一个元素： Michael Bob Tracy 所以for x in …循环就是把每个元素代入变量x，然后执行缩进块的语句。再比如我们想计算1-10的整数之和，可以用一个sum变量做累加： sum = 0 for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + x print(sum) 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： &gt;&gt;&gt; list(range(5)) [0, 1, 2, 3, 4] range(101)就可以生成0-100的整数序列，计算如下： sum = 0 for x in range(100 + 1): sum = sum + x print(sum) 请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。 pass 语句Python pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句 while True: pass #等待键盘中断 while循环第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 while n &gt; 0: sum = sum + n n = n - 2 print(sum) 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 无限循环(死循环)我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下： #!/usr/bin/python3 var = 1 while var == 1: # 表达式永远为 true print (&quot;你输入的数字是: &quot;, var) Var += 1 print (&quot;Good bye!&quot;) 你可以使用 CTRL+C 来退出当前的无限循环。请思考为什么有死循环，死循环可以做什么 while 循环使用 else 语句在 while … else 在条件语句为 false 时执行 else 的语句块： count = 0 while count &lt; 5: print (count, &quot; 小于 5&quot;) count = count + 1 else: print (count, &quot; 大于或等于 5&quot;) 0 小于 5 1 小于 5 2 小于 5 3 小于 5 4 小于 5 5 大于等于 5 break在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字： n = 1 while n &lt;= 100: print(n) n += 1 print(&apos;END&apos;) 上面的代码可以打印出1~100。如果要提前结束循环，可以用break语句： n = 1 while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1 print(&apos;END&apos;) 执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。可见break的作用是提前结束循环。 continue在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。 n = 0 while n &lt; 10: n = n + 1 print(n) 上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环： n = 0 while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。 小结循环是让计算机做重复任务的有效的方法。 break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。 要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。 大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。 有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。请试写一个死循环程序。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切片]]></title>
    <url>%2F2018%2F06%2F26%2Fpython%2Fpython%E4%B8%8A%2F15%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[切片格式items[start:end[:step]] #:step可以不写，默认步长是1 取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下： &gt;&gt;&gt; L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;] 取前3个元素，应该怎么做？笨办法： &gt;&gt;&gt; L[0], L[1], L[2] [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 之所以是笨办法是因为扩展一下，取前N个元素就没辙了。 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 对应上面的问题，取前3个元素，用一行代码就可以完成切片 &gt;&gt;&gt; L[0:3] [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略 &gt;&gt;&gt; L[:3] [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 也可以从索引1开始，取出2个元素出来 &gt;&gt;&gt; L[1:3] [&apos;Sarah&apos;, &apos;Tracy&apos;] 类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试 &gt;&gt;&gt; L[-2:] [&apos;Bob&apos;, &apos;Jack&apos;] &gt;&gt;&gt; L[-2:-1] [&apos;Bob&apos;] 记住倒数第一个元素的索引是-1。 切片操作十分有用。我们先创建一个0-99的数列： &gt;&gt;&gt; L = list(range(100)) &gt;&gt;&gt; L [0, 1, 2, 3, ..., 99] 可以通过切片轻松取出某一段数列。比如前10个数： &gt;&gt;&gt; L[:10] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数： &gt;&gt;&gt; L[-10:] [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前10个数，每两个取一个： &gt;&gt;&gt; L[:10:2] [0, 2, 4, 6, 8] 所有数，每5个取一个： &gt;&gt;&gt; L[::5] [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 甚至什么都不写，只写[:]就可以原样复制一个list： &gt;&gt;&gt; L[:] [0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： &gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： &gt;&gt;&gt; &apos;ABCDEFG&apos;[:3] &apos;ABC&apos; &gt;&gt;&gt; &apos;ABCDEFG&apos;[::2] &apos;ACEG&apos; Python没有针对字符串的截取函数，只需要切片操作就可以完成，非常简单。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期时间]]></title>
    <url>%2F2018%2F06%2F25%2Fpython%2Fpython%E4%B8%8A%2F14%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Time模块提供了处理时间和表示之间转换的功能 获取当前CPU时间可以统计一段程序代码的执行耗时time.clock() start = time.clock() for i in range(1, 1000): print(i) end = time.clock() print(end - start) 休眠程序推迟线程的执行，可以理解为暂停程序 time.sleep(秒数) calendar模块给定月份或年份打印文本日历的功能 &gt;&gt;&gt;import calendar &gt;&gt;&gt;print(calendar.month(2018, 6)) June 2018 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 datetime模块处理日期时间的标准库，这个模块里面有datetime类、time类和date类。 附：如要学习更多内容请自行百度学习]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不可变对象]]></title>
    <url>%2F2018%2F06%2F24%2Fpython%2Fpython%E4%B8%8A%2F13%E5%86%8D%E8%AE%AE%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前面我们讲了，str是不变对象，而list是可变对象。对于可变对象，比如list，对list进行操作，list内部的内容是会变化的 a = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;] a.sort() print(a) [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 而对于不可变对象，比如str，对str进行操作呢 &gt;&gt;&gt;a = &apos;abc&apos; &gt;&gt;&gt;a.replace(&apos;a&apos;, &apos;A&apos;) &apos;Abc&apos; &gt;&gt;&gt;print(a) &apos;abc&apos; 虽然字符串有个replace()方法，也确实变出了’Abc’，但变量a最后仍是’abc’，应该怎么理解呢？我们先把代码改成下面这样： &gt;&gt;&gt;a = &apos;abc&apos; &gt;&gt;&gt;b = a.replace(&apos;a&apos;, &apos;A&apos;) &apos;Abc&apos; &gt;&gt;&gt;a &apos;abc&apos; &gt;&gt;&gt;b &apos;Abc&apos; 要始终牢记的是，a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’当我们调用a.replace(‘a’, ‘A’)时，实际上调用方法replace是作用在字符串对象’abc’上的，而这个方法虽然名字叫replace，但却没有改变字符串’abc’的内容。相反，replace方法创建了一个新字符串’Abc’并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串’abc’，但变量b却指向新字符串’Abc’了所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。 小结使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F2018%2F06%2F23%2Fpython%2Fpython%E4%B8%8A%2F12%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[set和dict类似。是一个无序的、不可随机访问的、不可重复的元素集合。 &gt;&gt;&gt; s = set([1, 2, 3]) &gt;&gt;&gt; s {1, 2, 3} 注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。重复元素在set中自动被过滤： &gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3]) &gt;&gt;&gt; s {1, 2, 3} 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： &gt;&gt;&gt; s.add(4) &gt;&gt;&gt; s {1, 2, 3, 4} &gt;&gt;&gt; s.add(4) &gt;&gt;&gt; s {1, 2 3, 4} 通过remove(key)方法可以删除元素： &gt;&gt;&gt; s.remove(4) &gt;&gt;&gt; s {1, 2, 3} set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： &gt;&gt;&gt; s1 = {1, 2, 3} &gt;&gt;&gt; s2 = {2, 3, 4} &gt;&gt;&gt; s1 &amp; s2 {2, 3} &gt;&gt;&gt; s1 | s2 {1, 2, 3, 4} set和dict的唯一区别仅在于没有存储value，但set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。 集合分为可变集合和不可变集合==set为可变集合，可以进行增、删、改等操作。 ==frozenset为不可变集合，创建好后无法修改。 可变集合定义方式常见的有两种：方式一 s = {1,2,3,4} 方式二 s = set(可迭代对象) eg:s = set(1,2,3,4) 不可变集合定义方式 s = frozenset(可迭代对象) 注==可迭代对象iterable可以是一个元组，列表，字典等。== 当可迭代对象是一个字典时，只保留key做为集合的元素。==创建空集合时，要用set()，不能直接使用 se = {}，这样会被识别为字典==集合中的元素必须是不可变的。==如果集合中的元素出现重复，则把重复元素合并为一个。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典]]></title>
    <url>%2F2018%2F06%2F22%2Fpython%2Fpython%E4%B8%8A%2F11%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典是无序的，可变的键值对集合，使用键-值（key-value）存储，具有极快的查找速度。 命名规则 ==字典的每个键值(key：value)对用冒号(:)分割，多个键值对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示： d = {key1 : value1, key2 : value2 } ==键key不能重复，数据类型是不可变的，如字符串，数字或元组等类型。 实现原理 为什么dict查找速度快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，要查某一个字，一种是把字典从第一页往后翻，直到找到为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。 第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。 dict就是第二种实现方式，给定一个名字，比如’Michael’，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，直接取出来，所以速度非常快。你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。 字典的常用操作增格式：dict[key] = value说明：当key在原字典中不存在时，即为新增操作，否则为修改值操作。 删del 语句 格式：del dict[key]说明：key必须存在，否则报错 pop格式：dict.pop(key[ ,default])说明：删除指定的键值对，并返回对应的值如果key不存在，直接返回给定的default值，不作删除操作.如果没有给定默认值则报错 clear格式：dict.clear()说明：删除字典内所有的键值对，返回None字典对象本身还存在，只不过内容被清空 改只能改值，不能改key修改单个键值对格式：dict[key] = value 批量修改多个键值对格式：oldDict.update(newDict)说明：根据新的字典，批量更新旧字典中的键值对如果旧字典中没有对应的key,则新增键值对 查获取单个值方式一格式：dic[key]说明：如果key不存在则报错方式二格式：dic.get(key[,default])说明：如果不存在key，则返回default,没有default则返回None，不会报错 获取所有值获取值格式：dict.values() 获取键格式：dict.keys() 获取整个字典格式：dict.items() 遍历格式：for k,v in dict:说明：k是key,v是value附：如果用len函数统计字典内元素的个数是统计键的个数由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉 &gt;&gt;&gt; d[&apos;Jack&apos;] = 90 &gt;&gt;&gt; d[&apos;Jack&apos;] 90 &gt;&gt;&gt; d[&apos;Jack&apos;] = 88 &gt;&gt;&gt; d[&apos;Jack&apos;] 88 如果key不存在，dict就会报错： &gt;&gt;&gt; d[&apos;Thomas&apos;] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; KeyError: &apos;Thomas&apos; 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在： &gt;&gt;&gt; &apos;Thomas&apos; in d False 二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value： &gt;&gt;&gt; d.get(&apos;Thomas&apos;) &gt;&gt;&gt; d.get(&apos;Thomas&apos;, -1) -1 注意：返回None的时候Python的交互式命令行不显示结果。要删除一个key，用pop(key)方法，对应的value也会从dict中删除 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。 和list比较，dict有以下几个特点查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。而list相反：查找和插入的时间随着元素的增加而增加；占用空间小，浪费内存很少。所以，dict是用空间来换取时间的一种方法。 dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。 这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key： &gt;&gt;&gt; key = [1, 2, 3] &gt;&gt;&gt; d[key] = &apos;a list&apos; Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: unhashable type: &apos;list&apos;]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元组]]></title>
    <url>%2F2018%2F06%2F20%2Fpython%2Fpython%E4%B8%8A%2F10%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[元组是有序、不可变的元素集合，和列表的区别是tuple一旦初始化就不能修改，比如同样是列出同学的名字 &gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;) 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 空tuple写法 &gt;&gt;&gt; t = () &gt;&gt;&gt; t () 如果你这么定义1个元素的tuple写法： &gt;&gt;&gt; t = (1) &gt;&gt;&gt; t 1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： &gt;&gt;&gt; t = (1,) &gt;&gt;&gt; t (1,) tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如 &gt;&gt;&gt; t = (1, 2) &gt;&gt;&gt; t (1, 2) Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。 最后来看一个“可变的”tuple&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;]) &gt;&gt;&gt; t[2][0] = &apos;X&apos; &gt;&gt;&gt; t[2][1] = &apos;Y&apos; &gt;&gt;&gt; t (&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 这个tuple定义的时候有3个元素，分别是’a’，’b’和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？别急，我们先看看定义的时候tuple包含的3个元素： 表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 练习请用索引取出下面list的指定元素： # -*- coding: utf-8 -*- L = [ [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;], [&apos;Java&apos;, &apos;Python&apos;, &apos;Ruby&apos;, &apos;PHP&apos;], [&apos;Adam&apos;, &apos;Bart&apos;, &apos;Lisa&apos;] ] 打印Apple打印Python打印Lisa 小结list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表]]></title>
    <url>%2F2018%2F06%2F18%2Fpython%2Fpython%E4%B8%8A%2F9%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[列表List序列是Python中最基本的数据结构。是最常用的Python数据类型， 每个元素都分配一个数字 - 它的位置(或索引)，第一个索引是0，第二个索引是1，依此类推。 列表注意事项1：列表的数据项不需要具有相同的类型2;创建列表，只要用逗号分隔，把不同的数据项使用方括号括起来即可。3:用索引访问list中每个元素，索引值以 0 为开始值，-1 为从末尾的开始位置。 用索引访问列表Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。比如，列出班里所有同学的名字，就可以用一个list表示： &gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] &gt;&gt;&gt; classmates [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] 变量classmates就是一个list。用len()函数可以获得list元素的个数： &gt;&gt;&gt; len(classmates) 3 用索引来访问list中每一个位置的元素，记得索引是从0开始的： &gt;&gt;&gt; classmates[0] &apos;Michael&apos; &gt;&gt;&gt; classmates[1] #(如同对数组一样来操作) &apos;Bob&apos; &gt;&gt;&gt; classmates[2] &apos;Tracy&apos; &gt;&gt;&gt; classmates[3] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素： &gt;&gt;&gt; classmates[-1] &apos;Tracy&apos; 以此类推，可以获取倒数第2个、倒数第3个： &gt;&gt;&gt; classmates[-2] &apos;Bob&apos; &gt;&gt;&gt; classmates[-3] &apos;Michael&apos; &gt;&gt;&gt; classmates[-4] Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; IndexError: list index out of range 当然，倒数第4个就越界了。 列表的常用操作增、删、改、查、判定、排序、乱序、比较、反转 增：append功能：在列表元素末尾追加一个新元素语法：对象.append(想要添加的元素)返回值： None &gt;&gt;&gt; nums = [1, 2, 3, 4] &gt;&gt;&gt; nums.append(5) &gt;&gt;&gt;print(nums) [1, 2, 3, 4, 5] insert功能：在列表指定索引前面插入一个新的元素语法：对象.insert(索引, 想要添加的元素)返回值：None &gt;&gt;&gt; nums = [1, 2, 3, 4] &gt;&gt;&gt; nums.insert(1，5) &gt;&gt;&gt;print(nums) [1, 5, 2, 3, 4] extend功能：用一个可迭代对象，在原列表末尾扩展原列表语法：对象.extend(可迭代对象)返回值：None &gt;&gt;&gt; nums = [1, 2, 3, 4] &gt;&gt;&gt; lists = [5, 55, 555] &gt;&gt;&gt; nums.extend(lists) &gt;&gt;&gt;print(nums) [1, 2, 3, 4, 5, 55, 555] 注：可以看成两个集合的拼接 乘法运算功能：按数字重复打印列表 数字 次语法：列表 * 数字 &gt;&gt;&gt;[&quot;a&quot;] * 3 [&apos;a&apos;, &apos;a&apos;, &apos;a&apos;] 加法运算功能：将同类型的数据相加语法：[“a”] + [“b”,True] &gt;&gt;&gt;[&quot;a&quot;] + [&quot;b&quot;,5] [&apos;a&apos;, &apos;b&apos;, 5] 注：和extend区别：加法运算只能同类型相加 删del 语句功能：可以删除一个指定元素(对象)语法：del 指定元素 &gt;&gt;&gt;num = [1, 2, 3, 4] &gt;&gt;&gt;del num[1] &gt;&gt;&gt;print(num) [1, 3, 4] 注意：==可以删除整个列表==删除一个变量==也可以删除某个元素 pop功能：移除并返回列表中指定索引对应元素语法：对象.pop(index=-1)参数：index是需要被删除返回的元素索引，默认是-1，就是列表最后一个元素返回值：被删除的元素 &gt;&gt;&gt;num = [1, 2, 3, 4] &gt;&gt;&gt;num.pop() 4 &gt;&gt;&gt;num.pop(1) 2 &gt;&gt;&gt;print(num) [1, 3] &gt;&gt;&gt;num.pop(2) IndexError 注意：注意索引越界 remove功能：移除列表中指定元素语法：对象.remove(需要被删除的元素) &gt;&gt;&gt;strs = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] &gt;&gt;&gt;strs.remove(&apos;b&apos;) &gt;&gt;&gt;print(strs) [&apos;a&apos;, &apos;c&apos;, &apos;d&apos;] &gt;&gt;&gt;strs.remove(2) ValueError 注意：==如果元素不存在会报错==注：remove方法不能按数组下标的方式来删除数据项 改列表名[索引值] = 值 eg: names[6] = 666 查获取单个元素 items[index] 注:注意负索引 获取元素索引 index() 获取指定元素个数 count() 获取多个元素切片 items[start:end:step] 遍历方式1 方式2根据元素进行遍历 根据索引进行遍历 for item in list: for index in range(len(list)): print(item) print(index, list[index]) 判定元素 in 列表 #判断元素是否在列表 元素 not in 列表 #判断元素是否不在列表 比较用比较运算符去比较 注: python2.x 中，有个内建函数cmp。内建函数就是相当于print函数一样的，不需要额外导入包，可以直接在程序中使用的函数 排序方式一：内建函数sorted功能：可以对所有可迭代的对象进行排序语法：sorted(iterable, key = None, reverse = Flase)参数：iterable指可迭代对象，reverse指反转（默认是False,表示升序）key指排序关键字(这个值为一个函数，只有一个参数且返回一个值用来进行比较)返回值：一个已经排序好的列表 方式二：列表对象方法语法：list.sort( key = None, reverse = Flase) 附：方式一与方式二的差异(1)方式一可以操作的是可迭代对象，方式二仅仅可以操作列表(2)方式一返回处理后的结果，并不改变原数据本身；方式二无返回，原数据被改变 乱序可以随机打乱一个列表导入random模块eg: import randoml = [1,2,3,4,5]random.shuffle(l)注：返回值为None，该函数改变了原数据本身 反转方式一：列表对象方法reverse eg: list.reverse() 注：返回值为None，该函数改变了原数据本身方式二：切片反转 eg：list[::-1] 注：没有改变原数据本身 列表的多维与复制list里面的元素的数据类型也可以不同，比如： &gt;&gt;&gt; L = [&apos;Apple&apos;, 123, True] list元素也可以是另一个list，比如： &gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, [&apos;asp&apos;, &apos;php&apos;], &apos;scheme&apos;] &gt;&gt;&gt; len(s) 4 要注意s只有4个元素，其中s2又是一个list，如果拆开写就更容易理解了： &gt;&gt;&gt; p = [&apos;asp&apos;, &apos;php&apos;] &gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, p, &apos;scheme&apos;] 要拿到’php’可以写p1或者s2，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。 如果一个list中一个元素也没有，就是一个空的list，它的长度为0： &gt;&gt;&gt; L = [] &gt;&gt;&gt; len(L) 0 列表生成式功能：快速的生成列表格式： ==range(stop) --- [0, 1, 2, 3,..., stop-1] ==range(start,stop[, step]) --- [start, start+step,..., stop-1] 注：==start 默认是0，step是步长的意思，默认是1。==在python3中，为了防止生成的列表没有被使用，不会立即生成列表 列表推导式功能：从一个list推出另外一个list，简化了代码格式：[表达式 for 变量 in 列表 if条件] eg:将[1,2,3,4,5]这个列表中的每个元素分别平方，输出不能被2整除的元素 1: nums = [1,2,3,4,5] for num in nums: num2 = num**2; if num2%2 == 0: continue print(num2) 2:(1) nums = [1,2,3,4,5] numsPow = [num**2 for num in nums] &gt;&gt;&gt;numsPow [1,4,9,16,25] (2) nums = [1,2,3,4,5] numsPow = [num**2 for num in nums if num%2 != 0] &gt;&gt;&gt;numsPow [1,9,25] (3)还可以使用两层循环，可以生成全排列： &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;] [&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 三层和三层以上的循环就很少用到了。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化输出字符串]]></title>
    <url>%2F2018%2F06%2F16%2Fpython%2Fpython%E4%B8%8A%2F8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[一个常见的问题是如何输出格式化的字符串。我们经常会输出类似’亲爱的xxx你好！你xx月的话费是xx，余额是xx’之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。 在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下： &gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos; &apos;Hello, world&apos; &gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000) &apos;Hi, Michael, you have $1000000.&apos; 你可能猜到了，%运算符就是用来格式化字符串的。有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。常见的占位符有： 指定输出小数点精度 &gt;&gt;&gt; &apos;money %.2f&apos; % 45.728 money 45.73 注：.format()也可以格式化字符串，想了解的自行百度]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码(了解)]]></title>
    <url>%2F2018%2F06%2F15%2Fpython%2Fpython%E4%B8%8A%2F7%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[字符串也是一种数据类型，但是，字符串比较特殊的还有一个编码问题。 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。字母A用ASCII编码是十进制的65，二进制的01000001；字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的； 汉字 “中” 已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间： 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 x 01001110 00101101 11100100 10111000 10101101 从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。 搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式： 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件： 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器.所以你看到很多网页的源码上会有类似的信息，表示该网页正是用的UTF-8编码。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础知识整理_快速复习]]></title>
    <url>%2F2018%2F06%2F15%2Fpython%2FPython%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%2F01%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Python特点 一个广泛的标准库 ：Python 的最大的优势之一是丰富的库 可扩展 ：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用 C 或 C++ 完成那部分程序，然后从你的 Python 程序中调用。 基础语法交互式解释器在命令行窗口执行python后，进入 Python 的交互式解释器。exit() 或 Ctrl + D 组合键退出交互式解释器。 命令行脚本在命令行窗口执行python script-file.py，以执行 Python 脚本文件。 IDLEWindows环境下安装的Python，可以使用IDLE进行编程 编码默认情况下，3.x 源码文件都是 UTF-8 编码，字符串都是 Unicode 字符。也可以手动指定文件编码： # -*- coding: utf-8 -*- 或者 # encoding: utf-8 注意: 该行标注必须位于文件第一行 缩进Python 最具特色的就是使用缩进来表示代码块，缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。缩进不一致，会导致运行错误。 代码风格·使用 4 个空格来缩进 或者是 使用Tab键缩进，两者只选一个 ·永远不要混用空格和制表符 ·在函数之间空一行,在类之间空两行 ·字典、列表、元组以及参数列表中，在 ,后添加一个空格。 ·在赋值运算符和比较运算符周围要有空格，括号里侧不加空格：a = f(1, 2)+g(3, 4) 注释单行注释采用#，多行注释采用’’’或”””。 # 这是单行注释 &apos;&apos;&apos; 这是多行注释 这是多行注释 &apos;&apos;&apos; &quot;&quot;&quot; 这也是多行注释 这也是多行注释 &quot;&quot;&quot; 一条语句写多行通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠\来实现多行语句。 total = item_one + \ item_two + \ item_three 注意：在 [], {}, 或 () 中的多行语句，不需要使用反斜杠\。 多条语句写一行在同一行中使用多条语句，语句之间使用分号(;)分割 a = 23;b = ‘zylin’;c = True 注意：不建议这样写，最好一行一条语句 驼峰命名法==小驼峰式命名法（lower camel case）第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog ==大驼峰式命名法（upper camel case）每一个单字的首字母都采用大写字母，例如：FirstName、LastName注：还有一种命名法比较流行，就是用下划线来连接所有的单词，比如send_buf help() 函数调用 python 的 help() 函数可以打印输出一个函数的文档字符串．如下实例，查看 max 内置函数的参数列表和规范的文档 &gt;&gt;&gt; help(max) ……显示帮助信息…… 变量在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：(#在python中表示注释) a = 123 # a是整数 a = &apos;ABC&apos; # a变为字符串 这种变量本身类型不固定的语言称之为动态语言 变量在内存中的表示（重要）当我们写：a = ‘ABC’时，Python解释器干了两件事情： 1.在内存中创建了一个’ABC’的字符串； 2在内存中创建了一个名为a的变量，并把它指向’ABC’。 当然我们也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向了变量a指向的数据 标识符的命名(变量的命名)标识符由字母、数字和下划线组成。 标识符命名不能用数字开头。 标识符对大小写敏感。** Andy 不等于 andy python保留字保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字 &gt;&gt;&gt; import keyword &gt;&gt;&gt; keyword.kwlist 多个变量赋值Python允许你同时为多个变量赋值。例如： a = b = c = 1 以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。 您也可以为多个对象指定多个变量。例如： a, b, c = 1, 2, &quot;runoob&quot; 以上实例，两个整型对象 1 和 2 的分配给变量 a和b，字符串对象”runoob”分配给变量 c。 del语句python中的del用法比较特殊，新手学习往往产生误解 python的del不同于C的free和C++的delete。由于python都是引用，而python有GC机制，所以，del语句作用在变量上，而不是数据对象上。 del删除的是变量，而不是数据。另外。关于list后面再讲。 输入与输出输入格式：result = input(‘提示信息’)功能： ==会等待用户输入内容，直到用户按下Enter ==会将用户输入的内容当做”字符串”，传递给接收的变量 附：如想把用户输入的数据当成代码处理请参考eval()函数。 输出print(value,…,sep=” “,end=”\n”,file=sys.stdout,flush=False) 向屏幕上输出指定的文字 多个字符串，用逗号“,”隔开，就可以连成一串输出 sep=””可以设置多个字符串之间的分隔符，就是将逗号替换为双引号中的内容 end =””可以设置结尾的字符，可以将结尾的换行符换成双引号中的内容 file 表示输出的目标,默认是标准的输出(控制台),还可以是一个可写入的文件句柄 flush 表示立即输出的意思,需要输出的内容, 是先存放在缓冲区, 然后再输出到目标。flush,就代表是否刷新缓冲区,让缓冲区的内容,立即输出到目标,默认False 模块导入在 Python 用 import 或者 from…import 来导入相应的模块。 将整个模块导入，格式为：import module_name 从某个模块中导入某个函数,格式为：from module_name import func1 从某个模块中导入多个函数,格式为：from module_name import func1, func2, func3 将某个模块中的全部函数导入，格式为：from module_name import * #运算符 算术运算+、 -、 *、 /、 %、 //、 ** 比较运算==、!=、&gt;、&gt;=、&lt;、&lt;= 赋值运算=、+=、-=、*=、/=、%=、//=、**= 位运算&amp;、|、^、~、&lt;&lt;、&gt;&gt; 逻辑运算and、or、not 成员运算in、 not in 身份运算is、 is not 数据类型在Python中，能够直接处理的数据类型有以下六种： Number(数字) String(字符串) List(列表) Tuple(元组) Sets(集合) Dictionary(字典) 数值型Python支持三种不同类型 整型、浮点型、复数 整型(int)整数值，可正数亦可复数，无小数。 3.x 整型是没有限制大小的，可以当作 Long 类型使用，所以 3.x 没有 2.x 的 Long 类型。 浮点型(float)浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 10^2 = 250） 复数(complex)复数由实数部分和虚数部分构成，可以用a + bj，或者complex(a,b)表示，复数的实部 a 和虚部 b 都是浮点型。 数字运算不同类型的数字混合运算时会将整数转换为浮点数 在不同的机器上浮点运算的结果可能会不一样 在整数除法中，除法 / 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 //。 // 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系 在交互模式中，最后被输出的表达式结果被赋值给变量 _，_ 是个只读变量 数学函数注：以下函数的使用，需先导入 math 包。 函数 描述 abs(x) 返回数字的整型绝对值，如 abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如 math.ceil(4.1) 返回 5 cmp(x, y) 如果 x &lt; y 返回 -1，如果 x == y 返回 0，如果 x &gt; y 返回 1。Python 3 已废弃 。使用 使用 (x&gt;y)-(x&lt;y) 替换。 exp(x) 返回 e 的 x 次幂(ex)，如 math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的浮点数绝对值，如 math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如 math.floor(4.9) 返回 4 log(x) 如 math.log(math.e) 返回 1.0，math.log(100,10) 返回 2.0 log10(x) 返回以 10 为基数的 x 的对数，如 math.log10(100) 返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列 modf(x) 返回 x 的整数部分与小数部分，两部分的数值符号与 x 相同，整数部分以浮点型表示 pow(x, y) 幂等函数， x**y 运算后的值 round(x [,n]) 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数 sqrt(x) 返回数字 x 的平方根 随机数函数注：以下函数的使用，需先导入 random 包。 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 random() 随机生成下一个实数，它在[0,1)范围内 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内 三角函数注：以下函数的使用，需先导入 math 包。 函数 描述 acos(x) 返回 x 的反余弦弧度值 asin(x) 返回 x 的反正弦弧度值 atan(x) 返回 x 的反正切弧度值 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值 cos(x) 返回 x 的弧度的余弦值 hypot(x, y) 返回欧几里德范数 sqrt(x*x + y*y) sin(x) 返回的 x 弧度的正弦值 tan(x) 返回 x 弧度的正切值 degrees(x) 将弧度转换为角度，如 degrees(math.pi/2) 返回 90.0 radians(x) 将角度转换为弧度 数学常量注：以下常量的使用，需先导入 math 包。 常量 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e 即自然常数（自然常数） 字符串单引号和双引号使用完全相同 使用三引号(&apos;&apos;&apos;或&quot;&quot;&quot;)可以指定一个多行字符串 转义符(反斜杠\)可以用来转义，使用r可以让反斜杠不发生转义，如r&quot;this is a line with \n&quot;，则\n会显示，并不是换行 按字面意义级联字符串，如&quot;this &quot; &quot;is &quot; &quot;string&quot;会被自动转换为this is string 字符串可以用 + 运算符连接在一起，用 * 运算符重复 字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始 字符串不能改变 没有单独的字符类型，一个字符就是长度为 1 的字符串 字符串的截取的语法格式如下：变量[头下标:尾下标] 转义字符转义字符 描述 \ 在行尾时，续行符 \\ 反斜杠符号 \‘ 单引号 \“ 双引号 \a 响铃 \b 退格(Backspace) \e 转义 \000 空 \n 换行 \v 纵向制表符 \t 横向制表符 \r 回车 \f 换页 \oyy 八进制数，yy代表字符，例如：\o12代表换行 \xyy 十六进制数，yy代表字符，例如：\x0a代表换行 \other 其它的字符以普通格式输出 字符串运算符操作符 描述 实例 + 字符串连接 &apos;Hello&apos; + &apos;Python&apos; 输出结果：’HelloPython’ * 重复输出字符串 &apos;Hello&apos; * 2 输出结果：’HelloHello’ [] 通过索引获取字符串中字符 &apos;Hello&apos;[1] 输出结果 e [ : ] 截取字符串中的一部分 &apos;Hello&apos;[1:4] 输出结果 ell in 成员运算符，如果字符串中包含给定的字符返回 True &apos;H&apos; in &apos;Hello&apos; 输出结果 True not in 成员运算符，如果字符串中不包含给定的字符返回 True &apos;M&apos; not in &apos;Hello&apos; 输出结果 True r/R 原始字符串，所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法 print(r&apos;\n&apos;) 或 print(R&apos;\n&apos;) % 格式化字符串 格式化字符串字符串格式化在 Python 中，字符串格式化用 % 符号。例如： print(&quot;我有一只%s， 今年 %d 岁！&quot; % (&apos;小狗&apos;, 1)) #输出:我叫小狗， 今年 1 岁！ 格式化符号: 符号 描述 %c 格式化字符及其 ASCII 码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同 %e，用科学计数法格式化浮点数 %g %f 和 %e 的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 辅助指令: 指令 描述 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ’%%‘输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度，n 是小数点后的位数(如果可用的话) 字符串函数方法名 描述 str.capitalize() 首字母大写，其余字符小写 str.center(width[, fillchar]) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格 str.count(sub, start= 0,end=len(string)) 统计子字符串在字符串中出现的次数 str.encode(encoding=‘UTF-8’,errors=‘strict’) 以指定的编码格式编码字符串，返回 bytes 对象 bytes.decode(encoding=“utf-8”, errors=“strict”) 以指定的编码格式解码 bytes 对象，返回字符串 str.endswith(suffix[, start[, end]]) 判断字符串是否以指定后缀结尾 str.expandtabs(tabsize=8) 把字符串中的 tab 符号(\t)转为空格 str.find(str, beg=0, end=len(string)) 如果包含子字符串返回开始的索引值，否则返回-1 str.index(str, beg=0, end=len(string)) 如果包含子字符串返回开始的索引值，否则抛出异常 str.isalnum() 检测字符串是否只由字母和数字组成 str.isalpha() 检测字符串是否只由字母组成 str.isdigit() 检测字符串是否只由数字组成 str.islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False str.isupper() 检测字符串中所有的字母是否都为大写 str.isspace() 如果字符串中只包含空格，则返回 True，否则返回 False str.istitle() 检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写 str.join(sequence) 将序列的元素以指定的字符连接生成一个新的字符串 len(s) 返回对象（字符串、列表、元组等）长度或项目个数 str.ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串 str.lower() 转换字符串中所有大写字符为小写 str.upper() 转换字符串中所有小写字符为大写 str.strip([chars]) 移除字符串头尾指定的字符（默认为空格）或字符序列 str.maketrans(intab, outtab) 用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。两个字符串的长度必须相同，为一一对应的关系。 str.translate(table) 根据参数table给出的表转换字符串的字符 max(str) 返回字符串中最大的字符 min(str) 返回字符串中最小的字符 str.replace(old, new[, max]) 把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次 str.split(str=“”, num=string.count(str)) 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串 str.splitlines([keepends]) 按照行(’\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符 str.startswith(str, beg=0,end=len(string)) 检查字符串是否是以指定子字符串开头 str.swapcase() 对字符串的大小写字母进行互换 str.title() 返回”标题化”的字符串，即所有单词都是以大写开始，其余字母均为小写 str.zfill(width) 返回指定长度的字符串，原字符串右对齐，前面填充0 str.isdecimal() 检查字符串是否只包含十进制字符，只适用于 Unicode 对象 字节(bytes)在 3.x 中，字符串和二进制数据完全区分开。文本总是 Unicode，由 str 类型表示，二进制数据则由 bytes 类型表示。Python 3 不会以任意隐式的方式混用 str 和 bytes，你不能拼接字符串和字节流，也无法在字节流里搜索字符串 bytes 类型与 str 类型，二者的方法仅有 encode() 和 decode() 不同。 bytes 类型数据需在常规的 str 类型前加个 b 以示区分，例如 b&apos;abc&apos;。 只有在需要将 str 编码(encode)成 bytes 的时候，比如：通过网络传输数据；或者需要将 bytes 解码(decode)成 str 的时候，我们才会关注 str 和 bytes 的区别。 数据类型转换函数 说明 int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ])创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 列表(list)列表是一种无序的、可重复的数据序列，可以随时添加、删除其中的元素。 列表页的每个元素都分配一个数字索引，从 0 开始 列表使用方括号创建，使用逗号分隔元素 列表元素值可以是任意类型，包括变量 使用方括号对列表进行元素访问、切片、修改、删除等操作，开闭合区间为[)形式 列表的元素访问可以嵌套]]></content>
      <categories>
        <category>python基础复习整理</category>
      </categories>
      <tags>
        <tag>python基础复习整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2018%2F06%2F14%2Fpython%2Fpython%E4%B8%8A%2F6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下六种：Number(数字) String(字符串) List(列表) Tuple(元组) Sets(集合) Dictionary(字典) 注意：这章知识和上一章的知识点几乎不相上下，同时也是十分重要的。而且还有非常多的内置函数，这些内置函数实际上是不需要死记 的，如果真要用的话，随时上百度或者在python中用help查就好了 数值类型 【点我学习】.点我，点我，点我 字符类型 【点我学习】.点我，点我，点我 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来： &gt;&gt;&gt; True True &gt;&gt;&gt; 3 &gt; 5 False 布尔值可以用and、or和not运算。 数据类型转换举例 a = &apos;100&apos; # 此时a的类型是一个字符串，里面存放了100这3个字符 b = int(a) # 此时b的类型是整型，里面存放的是数字100 print(&quot;a=%d&quot;%b) 附：bin()函数将一个整数转换为一个二进制]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符]]></title>
    <url>%2F2018%2F06%2F12%2Fpython%2Fpython%E4%B8%8A%2F5%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Python语言支持以下类型的运算符算术运算符 比较（关系）运算符 赋值运算符逻辑运算符 位运算符 成员运算符身份运算符 运算符优先级接下来让我们一个个来学习Python的运算符。注意：这章知识点特别多，之前没有学习过类似的知识的朋友请认认真真的学，这很重要，所有举出来的案例一定要用心的多敲几遍，理解、消化掉。 算术运算符以下假设变量a为10，变量b为21。以下实例演示了Python所有算术运算符的操作： 实例 比较运算符以下假设变量a为10，变量b为20： 实例 赋值运算符以下假设变量a为10，变量b为20,以下实例演示了Python所有赋值运算符的操作： 实例 位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：下表中变量 a 为 60，b 为 13.以下实例演示了Python所有位运算符的操作： 实例 逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:and运算是与运算，只有所有都为True，and运算结果才是Trueor运算是或运算 ，只要其中有一个为True，or运算结果就是Truenot运算是非运算， 它是一个单目运算符，把True变成False，False变成True注：除零以外所有的数字都为True. 实例 成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。以下实例演示了Python所有成员运算符的操作： 实例 身份运算符身份运算符用于比较两个对象的存储单元注： id() 函数用于获取对象内存地址。以下实例演示了Python所有身份运算符的操作： 实例 is 与 == 区别：is用于判断两个变量引用对象是否为同一个，== 判断引用变量的值是否相等。 运算符优先级以下表格列出了从最高到最低优先级的所有运算符：以下实例演示了Python运算符优先级的操作 实例]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识]]></title>
    <url>%2F2018%2F06%2F10%2Fpython%2Fpython%E4%B8%8A%2F4%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[方便的使用Python[在IDLE中]–TAB补全代码：先键入一些代码，然后按下TAB键。 –回退代码：按下Alt + p 可以在当前位置上显示上一次输入的代码，按下Alt + n 可以显示下一条语句代码。 缩进 在Python中是重要的、最具特色的就是使用缩进来表示代码块，缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。（空格和制表符）用来决定缩进层次，从而用来决定语句的分组。你需要记住：错误的缩进会引发错误。例如： i = 5 print &apos;Value is&apos;, i # Error! Notice a single space at the start of the lineprint &apos;I repeat, the value is&apos;, i 当你运行这个程序的时候，你会得到下面的错误： File &quot;whitespace.py&quot;, line 4 print &apos;Value is&apos;, i # Error! Notice a single space at the start of the line ^ SyntaxError: invalid syntax 注意，在第二行的行首有一个空格。Python指示的这个错误告诉我们程序的语法是无效的，即程序没有正确地编写。它告诉你，你不能随意地开始新的语句块 。何时你能够使用新语句块，将会在后面的章节，如控制流中详细介绍。.. 代码风格建议 在 Python 中，空格很重要，我们使用空格将标识符区分开，行开始处的空格我们称之为缩进，如果缩进是错误的，解释器就会抛出错误。如果是用空格，就一直用空格缩进，不要使用制表符。建议遵守以下约定： ·使用 4 个空格来缩进 或者是 使用Tab键缩进，两者只选一个 ·永远不要混用空格和制表符 ·在函数之间空一行,在类之间空两行 ·字典、列表、元组以及参数列表中，在 ,后添加一个空格。 ·在赋值运算符和比较运算符周围要有空格，括号里侧不加空格：a = f(1, 2)+g(3, 4) Python3 注释确保对模块, 函数, 方法和行内注释使用正确的风格，Python中的注释有单行注释和多行注释单行注释以 # 开头，例如： # 这是一个注释 print(&quot;Hello, World!&quot;) 多行注释用三个单引号 ‘’’ 或者三个双引号 “”” 将注释括起来，例如: &apos;&apos;&apos; 这是多行注释，用三个单引号 这是多行注释，用三个单引号 &apos;&apos;&apos; 多行语句通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句 &gt;&gt;&gt;total = item_one + \ item_two + \ item_three 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如： &gt;&gt;&gt;total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;, &apos;item_four&apos;, &apos;item_five&apos;] 同一行显示多条语句Python可以在同一行中使用多条语句，语句之间使用分号(;)分割 &gt;&gt;&gt;a = 23;b = ‘zylin’;c = True help() 函数 调用 python 的 help() 函数可以打印输出一个函数的文档字符串．如下实例，查看 max 内置函数的参数列表和规范的文档 &gt;&gt;&gt; help(max)……显示帮助信息…… 编码 默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码： # -*- coding: cp-1252 -*- #coding:utf-8 注：在python2中如果直接在程序中用到了中文，比如如果直接运行输出，程序会出错。这时就需要用到上面这个语句，可以保证正确输出中文 del语句 python中的del用法比较特殊，新手学习往往产生误解 python的del不同于C的free和C++的delete。由于python都是引用，而python有GC机制，所以，del语句作用在变量上，而不是数据对象上。del删除的是变量，而不是数据。另外。关于list后面再讲。 命名规则见名知意 起一个有意义的名字，尽量做到看一眼就知道是什么意思(提高代码可 读性) 比如: 名字 就定义为 name , 定义学生 用 student 驼峰命名法==小驼峰式命名法（lower camel case）第一个单词以小写字母开始；第二个单词的首字母大写，例如：myName、aDog==大驼峰式命名法（upper camel case）每一个单字的首字母都采用大写字母，例如：FirstName、LastName注： 不过在程序员中还有一种命名法比较流行，就是用下划线来连接所有的单词，比如send_buf]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量与常量]]></title>
    <url>%2F2018%2F06%2F08%2Fpython%2Fpython%E4%B8%8A%2F3%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量 变量就是值能够随时发生改变的量。 也是一个存储数据的容器，变量可以是整数或浮点数，可以是字符串，还可以是任意数据类型。 静态语言与动态语言的声明方式差异在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：(#在python中表示注释) a = 123 # a是整数 a = &apos;ABC&apos; # a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 在Java中表示注释）： int a = 123; // a是整数类型变量 a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 不要把赋值语句的等号等同于数学的等号比如下面的代码： x = 10 x = x + 2 如果从数学上理解x = x+2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 变量在计算机内存中的表示（重要）当我们写：a = ‘ABC’时，Python解释器干了两件事情： 1.在内存中创建了一个’ABC’的字符串； 2在内存中创建了一个名为a的变量，并把它指向’ABC’。 当然我们也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向了变量a指向的数据，例如下面的代码： a = &apos;ABC&apos; b = a a = &apos;XYZ&apos; print(b) 最后一行打印出变量b的内容到底是’ABC’呢还是’XYZ’？如果从数学意义上理解，就会错误地得出b和a相同，也应该是’XYZ’，但实际上b的值是’ABC’，让我们一行一行地执行代码，就可以看到到底发生了什么事。1：执行a = ‘ABC’，解释器创建了字符串’ABC’和变量a，并把a指向’ABC’：(图一) 2：执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’：(图二) 3：执行a =’XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改所以，最后打印变量b的结果自然是’ABC’了。（图三） 多个变量赋值Python允许你同时为多个变量赋值。例如： a = b = c = 1 以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。 您也可以为多个对象指定多个变量。例如： a, b, c = 1, 2, &quot;runoob&quot; 以上实例，两个整型对象 1 和 2 的分配给变量 a和b，字符串对象”runoob”分配给变量 c。 标识符的命名(变量的命名)标识符由字母、数字和下划线组成。 标识符命名不能用数字开头。 标识符对大小写敏感。** Andy 不等于 andy 有效标识符名称的例子有i、__my_name、name_23和a1b2_c3。无效标识符名称的例子有2things、this is spaced out和my-name。 python保留字 保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： 常量 所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量如： PI = 3.14159265359 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入与输出]]></title>
    <url>%2F2018%2F06%2F07%2Fpython%2Fpython%E4%B8%8A%2F2%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[输出print(value,…,sep=” “,end=”\n”,file=sys.stdout,flush=False) 用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。print()函数也接受多个字符串，用逗号“,”隔开，就可以连成一串输出：&gt;&gt;&gt;print(&#39;hello&#39;, &#39; world&#39;)hello world sep=””可以设置多个字符串之间的分隔符，就是将逗号替换为双引号中的内容end =””可以设置结尾的字符，可以将结尾的换行符换成双引号中的内容&gt;&gt;&gt;print(&quot;hello&quot;,&quot;world&quot;,sep = &quot;A&quot;,end = &quot;TT&quot;)helloAworldTT file 表示输出的目标,默认是标准的输出(控制台),还可以是一个可写入的文件句柄flush 表示立即输出的意思,需要输出的内容, 是先存放在缓冲区, 然后再输出到目标flush,就代表是否刷新缓冲区,让缓冲区的内容,立即输出到目标,默认False 加号是将两个字符串连接到一起。乘号是将字符串重复打印&gt;&gt;&gt; print(“Hello”+” World”)Hello World&gt;&gt;&gt; print(“Hello” * 8)HelloHelloHelloHelloHelloHelloHelloHello &gt;&gt;&gt; print(“Hello World” + 8)error,字符串不能做加法运算 输入格式：result = input(‘提示信息’)功能： ==会等待用户输入内容，直到用户按下Enter ==会将用户输入的内容当做”字符串”，传递给接收的变量附：如想把用户输入的数据当成代码处理请参考eval()函数。 练习1：请利用print()输出1024 * 768 = xxx： 2：提示用户并让用户输入今天的日期时间]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的安装与使用]]></title>
    <url>%2F2018%2F06%2F06%2Fpython%2Fpython%E4%B8%8A%2F1Python%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python的文件你可以用任意文本编辑器建立源代码，但是绝大多数Python文件为了统一都是以.py命名的。 在Windows上安装Python 首先，根据你的Windows版本（64位还是32位）从Python的官方网站下载Python．然后，运行下载的EXE安装包 我们可以通过Python官方网站下载获得Python。因为Python是跨平台的，在Windows上写Python程序，放到Linux上也是能够运行的。特别要注意勾上Add Python 3.5 to PATH，然后点“Install Now”即可完成安装。注：这是当时作者安装时的版本，如要安装新的版本请按类似操作进行选择附：作者建议安装32位的版本，因为64位的python编写的程序无法在32位机上跑程序， 使用IDLE来帮助学习Python因为这个对新手非常友好 –IDLE是安装Python时就同时安装好的，在windows环境下，你可以在开始菜单中找到. –第一次启动IDLE时，会显示“三个大于号”提示符(&gt;&gt;&gt;)，可以在这里输入代码。shell在得到你的代码后会立即执行，并在屏幕上显示生成的结果。与交互模式下的运行方式一样： 使用文本编辑器选择IDLE里的新建选项打开我们的Python自带的文本编辑器。 请注意，绝对不能用Word和Windows自带的记事本。Word保存的不是纯文本文件，而记事本会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果会导致程序运行出现莫名其妙的错误。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python简介(了解)]]></title>
    <url>%2F2018%2F06%2F05%2Fpython%2Fpython%E4%B8%8A%2F0Python%E7%AE%80%E4%BB%8B(%E4%BA%86%E8%A7%A3)%2F</url>
    <content type="text"><![CDATA[Python简介（了解）Python是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行1991年。Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL协议。Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。 排行：7月20日，IEEE发布2017年编程语言排行榜：Python高居首位。 设计定位:Python的设计哲学是“优雅”、“明确”、“简单”。“总是有多种方法来做同一件事”通常是难以忍受的。Python的哲学是“用一种方法，最好是只有一种方法来做一件事”。由于这种设计观念的差异，Python源代码通常被认为比Perl具备更好的可读性，并且能够支撑大规模的软件开发。 Python更新:开发人员尽量避开不成熟或者不重要的优化。一些针对非重要部位的加快运行速度的补丁通常不会被合并到Python内。所以很多人认为Python很慢。不过，根据二八定律，大多数程序对速度要求不高。在某些对运行速度要求很高的情况，Python设计师倾向于使用JIT技术，或者用使用C/C++语言改写这部分程序。可用的JIT技术是PyPy。 执行:Python在执行时，首先会将.py文件中的源代码编译成Python的字节码，然后再由 Python虚拟机 来执行这些编译好的字节码。这种机制的基本思想跟Java，.NET是一致的。然而不同的是，Python的虚拟机是一种更高级的虚拟机。这里的高级并不是通常意义上的高级，不是说比Java或.NET的功能更强大，而是和Java 或.NET相比，Python的虚拟机距离真实机器的距离更远。或者可以认为Python的虚拟机是一种抽象层次更高的虚拟机。基于C的Python编译出的字节码文件，通常是.pyc格式。除此之外，Python还可以以交互模式运行，比如主流操作系统Unix/Linux、Mac、Windows都可以直接在命令模式下直接运行Python交互环境。直接下达操作指令即可实现交互操作。 优点简单：Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样。它使你能够专注于解决问题而不是去搞明白语言本身。 免费、开源：使用者可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。可移植性：这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、PalmOS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE、PocketPC、Symbian以及Google基于linux开发的android平台。可扩展性：如果需要一段关键代码运行得更快或者希望某些算法不公开，可以部分程序用C或C++编写，然后在Python程序中使用它们。规范的代码：Python采用强制缩进的方式使得代码具有较好可读性。而Python语言写的程序不需要编译成二进制代码。 缺点⑴运行速度。但是如果有速度要求的话，可以用C/C++改写关键部分吧。 ⑵python的开源性使Python语言不能加密。关于不能加密这点，作者想说，在这个时代，大家的时间辣么宝贵，才有那闲功夫去破解你的软件，洗洗睡吧 ⑶构架选择太多。不过这也从另一个侧面说明，python比较优秀，吸引的人才多，项目也多。 Python应用场景Web应用开发 Python经常被用于Web开发。比如，通过mod_wsgi模块，Apache可以运行用Python编写的Web程序。Python定义了WSGI标准应用接口来协调Http服务器与基于Python的Web程序之间的通信。一些Web框架，如Django,TurboGears,web2py,Zope等，可以让程序员轻松地开发和管理复杂的Web程序。 操作系统管理、服务器运维的自动化脚本 在很多操作系统里，Python是标准的系统组件。 大多数Linux发行版以及NetBSD、OpenBSD和Mac OS X都集成了Python，可以在终端下直接运行Python。有一些Linux发行版的安装器使用Python语言编写，比如Ubuntu的Ubiquity安装器,Red Hat Linux和Fedora的Anaconda安装器。Gentoo Linux使用Python来编写它的Portage包管理系统。Python标准库包含了多个调用操作系统功能的库。通过pywin32这个第三方软件 包，Python能够访问Windows的COM服务及其它Windows API。使用IronPython，Python程序能够直接调用.Net Framework。一般说来，Python编写的系统管理脚本在可读性、性能、代码重用度、扩展性几方面都优于普通的shell脚本。 科学计算 NumPy,SciPy,Matplotlib可以让Python程序员编写科学计算程序。 桌面软件 PyQt、PySide、wxPython、PyGTK是Python快速开发桌面应用程序的利器。 服务器软件（网络软件） Python对于各种网络协议的支持很完善，因此经常被用于编写服务器软件、网络爬虫。第三方库Twisted支持异步网络编程和多数标准的网络协议(包含客户端和服务器)，并且提供了多种工具，被广泛用于编写高性能的服务器软件。 游戏 很多游戏使用C++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小；而Python则支持更多的特性和数据类型。 构思实现，产品早期原型和迭代 YouTube、Google、Yahoo!、NASA都在内部大量地使用Python。]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要学习Python？]]></title>
    <url>%2F2018%2F06%2F03%2Fpython%2Fpython%E4%B8%8A%2F001%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0Python%2F</url>
    <content type="text"><![CDATA[3W2H法是通过自问自答以下５个问题，然后寻找这５个问题的答案，通过寻找答案的过程，达到分析问题的目的。 What ：什么是Python Who ：谁在使用Python Why ：为什么使用Python How ：如何学习Python How Continue：如何持续地去提高Python What——什么是PythonPython：一种免费、自由的编程语言，主要用来统计分析、绘图以及数据挖掘，是一款强大的数据统计分析、数据可视化工具 Who ：谁在使用Python系统应用 软件开发、游戏开发、系统维护…… 互联网 Web开发、系统运维、网络服务…… 统计分析 统计分布、假设检验、统计建模…… 数据挖掘 挖掘算法、数据建模、机器学习…… 数据可视化 直方图、散点图、折线图…… ……………… Why ：为什么使用PythonPython是一种解释型、动态语言，具有明确而高效的语法 Python不断地从其他优秀的数学软件引入高效的数据开发包 数据处理：Pandas、数据计算：NumPy、数据可视化：matplotlib Python被称为可执行的伪代码，有着优美的代码风格 How and How Continue编程——实战案例 分析——理解算法]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的学习教程]]></title>
    <url>%2F2018%2F06%2F01%2Fpython%2Fpython%E4%B8%8A%2F00%E5%AD%A6%E4%B9%A0%E6%9D%A5%E6%BA%90%2F</url>
    <content type="text"><![CDATA[后面所有写的内容都是我从下面这些网站上学习的笔记，大家也可以前往这些网站去学习，里面有非常多的优秀的教学资源，而且都是免费的 CSDN专业IT技术社区瘳雪峰的官方网站菜鸟教程]]></content>
      <categories>
        <category>python基础编程</category>
      </categories>
      <tags>
        <tag>python基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷茫]]></title>
    <url>%2F2018%2F05%2F25%2F%E6%97%A5%E5%B8%B8%2F%E6%97%A5%E8%AE%B0%2F001%E8%BF%B7%E8%8C%AB%2F</url>
    <content type="text"><![CDATA[之前还期待着拿到神功秘籍，一个月就可以神功大成。人总是希望着有朝一日可以顿悟，经过事实证明，想的太美也不是什么好事。 现在这个社会，说是步入了快节奏，知识的获取也应该架设起高速，人的注意力降到3~5分钟，这是某些推送文章的理念，过多的时间就是注意力的转移 试过各种速成大法，21天学会某某某，学这个3个月后月薪过万，最终还是不明觉厉，他们把过多的精华集中在一页，不重要的能减就减，结果学了个大概，道理也能说上一点，一动手就露却了，花了时间，送了金钱，还是啥也不会 当自己迷茫时，觉得自己什么都不会的时候，不妨试着让自己慢下来，一步步的来，所以我想，把自己以前学的内容，慢慢总结归纳，写成博客，更扎实的掌握好自己学的知识。 一篇博客总结下来，至少1个小时，遇到自己还是比较模糊的概念时，或者难以用自己的语言表达时，有时甚至一两天，但我没有更好的选择了，做笔记是方法，写博客也是方法，相比下还是写博客好 饭是一口一口吃的，不能想着一次吃一个星期的饭，后面一个星期就可以不吃了 道理谁都明白，可是都不想去选择]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%97%A5%E5%B8%B8%2F%E6%97%A5%E8%AE%B0%2F000%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[从上大学开始就想着有一个属于自己的个人网站，可以在上面记录下自己的学习历程。到今天，这才实现了我这个想法。 想起了大一时的一腔热血，一头扎进了各种快速建站，结果在服务器的价格与域名备案上退缩了，想起来也是好笑。不管怎样，今天，是一个开心的日子。 每一个不曾起舞的日子都是对生命的辜负 加油，越努力，越幸运！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[房间里有头大象]]></title>
    <url>%2F2018%2F05%2F19%2F%E6%97%A5%E5%B8%B8%2F%E4%B8%8E%E4%BA%BA%E7%9B%B8%E5%A4%84%2F0%E6%88%BF%E9%97%B4%E9%87%8C%E6%9C%89%E5%A4%B4%E5%A4%A7%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[我的女儿萨拉问我能否为她打造一款特别的家具，我满口答应：“当然没问题！”事实上，这算是我许诺给她的圣诞礼物。 这是两年前的事儿了。 问题是，我并不知道该怎样打造这个家具。我善于按照计划开展行动，但拙于直接在行动中摸索。这件事情并没有既定规划，我试着思考怎么做，但毫无结果。所以，我就把这事儿搁置了好几个星期，期待着解决之道会在脑海中慢慢浮现出来，然后我就知道应该怎么去做了。 但一两个星期之后，什么都没有改变，事情毫无进展。“女儿的家具”被我搁置了一周又一周、一个月又一个月——因为我被难住了。当我对什么事情束手无策的时候，我的默认做法就是拖延，而不是一鼓作气去解决它。 每次萨拉跟我说话的时候，我都小心翼翼地回避这个话题。我不想让她失望，也不想承认自己的无能。我们从来不聊这事儿，她也不知道究竟是怎么了。我猜想她要么对我很生气，要么对我很失望。但我没有问她，所以也不确定——我想，我其实是不敢去问。 我终于意识到，这样的状态在我们中间形成了一道彼此心照不宣的隔阂。在这个世界上，我的女儿是我最愿意与之聊天的人之一，我希望我们父女之间亲密有爱。但是，我的沉默筑造了一堵无声的墙，两年来，这堵墙越来越高。 当我意识到发生了什么，就马上和女儿说了我的感受，并向她道歉，希望尽我所能去化解自己造成的隔阂。 我说这些的时候，她回答说：“是的，房间里有只大象。” “房间里有头大象”用来形容某些显而易见的事情正在发生，可所有人都避而不谈，而且假装什么都没发生。 我的脑海中浮现出了一个场景：我坐在客厅一端，我的女儿坐在对面的另一端，我们从大象腿之间的缝隙里互望，试着说话。那头大象几乎塞满了整个房间，气味难闻，而且非常聒噪，但是我们都不提它。 一旦我们承认了它，我们就会想：这么一个庞然大物是怎么进入房间的？跟大象比起来，门这么小，根本不可能让它通过！ 听着似曾相识？在你的生命中是否也有人与你分享着“一头大象”——你们对某些事儿心知肚明，却没人愿意提及？没人愿意谈是因为提起来会很不舒服，还会惹得人们心烦意乱。大象待在那儿的时间越长，人们就越难开口。但是它又扎眼又难闻，妨碍着人与人之间的真诚交流。 所以，那个大家伙当初是怎么进门儿的？ 在它还小的时候进来的。 如果这头大象刚刚进来的时候我们就坦诚交流，就能轻轻松松地将它引出门去。但是当我们坐视不管，任由它留下来，日复一日，小象不断长大，再处理起来就麻烦多了。一旦它长成庞然大物，我们可能需要拆房子，请求专业协助才能处理它。 当我最终向女儿承认了“那头大象”，她说：“如果你早点儿告诉我你做不出来，我们可以花上一天的时间好好商量商量，直到我们找到解决办法。”那想必会是我们父女一起度过的非常美好的一天。我们可以去咖啡馆喝杯咖啡，也可以一起去逛五金店或者木材市场。 我爱我的女儿，而且我很开心我们一起解决了问题，她很高兴我做好了那件“家具”。我们家里再也没有“大象”的臭味儿了。 明白了吗？我们一定要提防房间里出现小象，如果你放任它们待在房间里，它们真的会长得很大、很大。]]></content>
      <categories>
        <category>与人相处</category>
      </categories>
      <tags>
        <tag>与人相处</tag>
      </tags>
  </entry>
</search>
